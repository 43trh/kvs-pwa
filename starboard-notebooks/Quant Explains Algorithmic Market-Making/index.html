<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Starboard Notebook</title>
        <meta name="viewport" content="width=device-width,initial-scale=1">
        <link rel="icon" href="https://cdn.jsdelivr.net/npm/starboard-notebook@0.15.2/dist/favicon.ico">
        <link href="https://cdn.jsdelivr.net/npm/starboard-notebook@0.15.2/dist/starboard-notebook.css" rel="stylesheet">
    </head>
    <body>
        <script>
            window.initialNotebookContent = `---\njupystar:\n  version: 0.1.5\n---\n# %% [markdown]\n### \u{1F4C8} Quant Explains Algorithmic Market-Making\n\n##### ▶️ Related Quant Guild Videos:\n\n- [Time Series Analysis for Quant Finance](https://youtu.be/JwqjuUnR8OY)\n\n- [Quant Trader on Retail vs Institutional Trading](https://youtu.be/j1XAcdEHzbU)\n\n- [Quant on Trading and Investing](https://youtu.be/CKXp_sMwPuY)\n\n- [Why Poker Pros Make the Best Traders (It's NOT Luck)](https://youtu.be/wZChBKDFFeU)\n\n- [Quant vs. Discretionary Trading](https://youtu.be/3gblERSSHXI)\n\n- [Quant Busts 3 Trading Myths with Math](https://youtu.be/wJfIk3VnubE)\n\n###### ______________________________________________________________________________________________________________________________________\n\n##### [\u{1F680} Master your Quantitative Skills with Quant Guild](https://quantguild.com)\n\n##### [\u{1F4C5} Want to chat?  Meet with me 1:1](https://calendly.com/quantguild-support)\n\n##### [\u{1F4DA} Visit the Quant Guild Library for more Jupyter Notebooks](https://github.com/romanmichaelpaolucci/Quant-Guild-Library)\n\n##### [\u{1F4C8} Interactive Brokers for Algorithmic Trading](https://www.interactivebrokers.com/mkt/?src=quantguildY&url=%2Fen%2Fwhyib%2Foverview.php)\n\n##### [\u{1F47E} Quant Guild Discord](discord.com/invite/MJ4FU2c6c3)\n\n---\n# %% [html]\n<style>\n/* Overwrite the hard-coded white background for ipywidgets */\n.cell-output-ipywidget-background {\n    background-color: transparent !important;\n}\n/* Set widget foreground text and color to match the VS Code dark theme */\n:root {\n    --jp-widgets-color: var(--vscode-editor-foreground);\n    --jp-widgets-font-size: var(--vscode-editor-font-size);\n}\n<\/style>\n# %% [markdown]\n### \u{1F4D6} Sections\n\n#### 1.) \u{1F3B2} Making a Dice Market\n\n- Finding the mid price\n\n- Quoting a spread\n\n- Making a market\n\n#### 2.) \u{1F4C8} Making an Options Market\n\n- Finding the mid price\n\n- Quoting a spread (with adjustments)\n\n- Making a market (and hedging)\n\n#### 3.) \u{1F4AD} Closing Thoughts and Future Topics\n# %% [markdown]\n---\n# %% [markdown]\n#### 1.) \u{1F3B2} Making a Dice Market\n\nYou are a trader at a bank, a client requests a two way (bid, ask/offer) for a dice market\n\n**Market-Making Basics**\n - **Bid**: price client sells at \n - **Ask/Offer**: price client buys at \n\nIn this market, traders can go long and short the value of a dice roll and once the die is rolled they will realize P/L\n\n**For example,**\n\n1.) Trader goes long 1,000 shares @ $3/share\n\n2.) A dice is rolled and the outcome of 6 is realized\n\n3.) The trader realizes a P/L of $3/share or $3,000\n\n*What price should you quote them?*  \n\nThe outcome is *entirely random* can we still make money in a stable way?\n\n##### Remark:  Our Statistical Edge / Trade Dictates the Drift of Our Wealth Process\n\n \n $$\n \\mathbb{E}[\\text{Trader P\\&L}] > 0 \\implies \\text{Accumulate Positive Edge}\n $$\n\n $$\n\\mathbb{E}[\\text{Trader P\\&L}] < 0 \\implies \\text{Accumulate Negative Edge}\n $$\n\n# %% [python]\nimport numpy as np\nimport plotly.graph_objs as go\nfrom plotly.subplots import make_subplots\n\n# ---------------------------------------------\n### CONFIGURATION LEVER ###\n# Change this variable to switch the simulation type: "POSITIVE" or "NEGATIVE"\nPLOT_EDGE_TYPE = "POSITIVE" \n# ---------------------------------------------\n\nN_PATHS = 20     # Number of simulation paths to display\nn_steps = 120    # Total time steps\n\n# Parameters for edge calculation\nliquidity_k = 0.85 \nspread = 1\nhit_rate = np.exp(-liquidity_k * spread)\n\n# Define the theoretical EV for each scenario\nEV_POSITIVE_STRONG = 1.0 # **INCREASED DRIFT: Changed from 0.5 to 1.0**\nEV_NEGATIVE = -1.0 \n\n# **Variability Parameter**\nVOLATILITY = 0.3 \n\n# Select parameters based on the configuration lever\nif PLOT_EDGE_TYPE == "POSITIVE":\n    EV_PER_TRADE = EV_POSITIVE_STRONG\n    EDGE_LABEL = f"Strong Effective Market-Making (+{EV_PER_TRADE} EV/Trade)"\n    PATH_COLOR = '#198754'  # Green\nelif PLOT_EDGE_TYPE == "NEGATIVE":\n    EV_PER_TRADE = EV_NEGATIVE\n    EDGE_LABEL = f"Ineffective Market-Making ({EV_NEGATIVE} EV/Trade)"\n    PATH_COLOR = '#DC3545'  # Red\nelse:\n    raise ValueError("PLOT_EDGE_TYPE must be 'POSITIVE' or 'NEGATIVE'")\n\nEV_AVG = EV_PER_TRADE * hit_rate # Average P&L per time step (Expected Value)\n\ndef calculate_sharpe(returns, risk_free_rate=0):\n    """Calculates the Sharpe Ratio given a series of P&L values."""\n    step_returns = np.diff(returns, prepend=0)\n    avg_return = np.mean(step_returns)\n    std_dev = np.std(step_returns)\n    \n    if std_dev == 0:\n        return 0.0\n    \n    sharpe = (avg_return - risk_free_rate) / std_dev\n    return sharpe\n\ndef simulate_edge_multiple(N_paths, n_steps, hit_rate, ev_per_trade, vol):\n    """Runs multiple simulations and returns a list of P&L series."""\n    pl_series_list = []\n    time_steps = np.arange(1, n_steps + 1)\n    \n    for _ in range(N_PATHS):\n        cum_pl = 0\n        cum_pl_series = np.zeros_like(time_steps, dtype=float)\n        \n        for t in range(n_steps):\n            if np.random.uniform() < hit_rate:\n                trade_pl = ev_per_trade\n            else:\n                trade_pl = 0\n            \n            # Add random noise/volatility\n            noise = np.random.normal(0, vol)\n            \n            cum_pl += trade_pl + noise\n            cum_pl_series[t] = cum_pl\n            \n        pl_series_list.append(cum_pl_series)\n        \n    return time_steps, pl_series_list\n\n# Run the selected simulation\ntime_steps, pl_paths = simulate_edge_multiple(N_PATHS, n_steps, hit_rate, EV_PER_TRADE, VOLATILITY)\n\n\n# --- STYLING & COLOR CHOICES ---\nAVG_LINE_COLOR = '#6AAED6'  \nLINE_WIDTH_INDIVIDUAL = 2   \nLINE_WIDTH_AVG = 4          \nPATH_OPACITY = 0.3          \nGRID_COLOR = '#505050'\nFONT_COLOR = 'white' \nTRANSPARENT = 'rgba(0,0,0,0)'\n\n# --- ZERO-JITTER AXIS SETUP (Fixed Ranges) ---\nall_pl = np.concatenate(pl_paths)\nGLOBAL_Y_MAX = max(np.max(all_pl), 0)\nGLOBAL_Y_MIN = min(np.min(all_pl), 0)\nGLOBAL_Y_DELTA = GLOBAL_Y_MAX - GLOBAL_Y_MIN\nGLOBAL_Y_PAD = max(GLOBAL_Y_DELTA * 0.15, 2) \nSTABLE_Y_RANGE = [GLOBAL_Y_MIN - GLOBAL_Y_PAD, GLOBAL_Y_MAX + GLOBAL_Y_PAD]\n\nX_MARGIN = 5\nSTABLE_X_RANGE = [0, n_steps + X_MARGIN]\n\n# --- CREATE SUBPLOTS FIGURE ---\nfig_anim = make_subplots(\n    rows=1, cols=1,\n    subplot_titles=(EDGE_LABEL,), # Dynamic title\n)\n\n# --- CREATE ANIMATION FRAMES ---\nframes = []\n\nframe_steps = (\n    list(range(1, min(20, n_steps) + 1)) +\n    list(range(21, min(60, n_steps) + 1, 3)) +\n    list(range(61, n_steps + 1, 5))\n)\n\nfor i in frame_steps:\n    x = time_steps[:i]\n    \n    # Calculate Sharpe Ratio for the current time step (i)\n    current_paths_pl = [path[:i] for path in pl_paths]\n    current_sharpe_ratios = [calculate_sharpe(path) for path in current_paths_pl]\n    avg_sharpe = np.mean(current_sharpe_ratios) if current_sharpe_ratios else 0.0\n    \n    frame_data = []\n\n    # Individual Paths\n    for k in range(N_PATHS):\n        frame_data.append(\n            go.Scatter(x=x, y=pl_paths[k][:i], mode="lines", \n                       line=dict(color=PATH_COLOR, width=LINE_WIDTH_INDIVIDUAL), opacity=PATH_OPACITY, \n                       name=f"Path {k}", legendgroup='path', showlegend=False)\n        )\n    # Theoretical Average Line\n    frame_data.append(\n        go.Scatter(x=x, y=x * EV_AVG, mode="lines", \n                   line=dict(color=AVG_LINE_COLOR, width=LINE_WIDTH_AVG, dash='dot'), \n                   name="Theoretical Avg", legendgroup='path', showlegend=False)\n    )\n\n    frame = go.Frame(\n        data=frame_data,\n        name=str(i),\n        layout=go.Layout(\n            # Annotation showing AVERAGE SHARPE - Adjusted position\n            annotations=[\n                dict(\n                    x=STABLE_X_RANGE[0] + (X_MARGIN * 0.5), # Shifted left (near x=0)\n                    y=STABLE_Y_RANGE[1] - (GLOBAL_Y_PAD * 2.5), # Shifted down from the top edge\n                    xref="x1", yref="y1",\n                    text=f"Avg Sharpe (T={i}): {avg_sharpe:.3f}", \n                    showarrow=False,\n                    font=dict(color=FONT_COLOR, size=16), \n                    bgcolor="rgba(0,0,0,0.5)", \n                    bordercolor=FONT_COLOR,\n                    xanchor='left', \n                    yanchor='top' \n                ),\n            ]\n        )\n    )\n    frames.append(frame)\n\n# --- INITIAL TRACES FOR BASE FIGURE ---\ninitial_i = frame_steps[0]\ninit_x = time_steps[:initial_i]\n\n# Traces for the legend \nfig_anim.add_trace(go.Scatter(x=[0], y=[0], mode='lines', \n                              line=dict(color=PATH_COLOR, width=LINE_WIDTH_INDIVIDUAL), opacity=PATH_OPACITY,\n                              name='Individual Path (20x)', legendgroup='legend', showlegend=True), row=1, col=1)\n\nfig_anim.add_trace(go.Scatter(x=[0], y=[0], mode='lines', \n                              line=dict(color=AVG_LINE_COLOR, width=LINE_WIDTH_AVG, dash='dot'), \n                              name='Theoretical Average', legendgroup='legend', showlegend=True), row=1, col=1)\n\n# Add initial paths\nfor k in range(N_PATHS):\n    fig_anim.add_trace(go.Scatter(x=init_x, y=pl_paths[k][:initial_i], mode='lines', \n                                  line=dict(color=PATH_COLOR, width=LINE_WIDTH_INDIVIDUAL), opacity=PATH_OPACITY,\n                                  name=f'Path {k}', legendgroup='path', showlegend=False), row=1, col=1)\n\n# Add initial average line\nfig_anim.add_trace(go.Scatter(x=init_x, y=init_x * EV_AVG, mode="lines", \n                              line=dict(color=AVG_LINE_COLOR, width=LINE_WIDTH_AVG, dash='dot'), \n                              name="Theoretical Avg", legendgroup='path', showlegend=False), row=1, col=1)\n\n\n# --- LAYOUT CONFIGURATION ---\ntitle_text = f"✨ Ergodic Convergence: Accumulation of {PLOT_EDGE_TYPE.capitalize()} Edge" \n\nfig_anim.update_layout(\n    title=dict(\n        text=title_text, \n        x=0.5, font=dict(color=FONT_COLOR, size=24, family="Arial, sans-serif")\n    ),\n    plot_bgcolor=TRANSPARENT, \n    paper_bgcolor=TRANSPARENT, \n    font=dict(color=FONT_COLOR, size=12),\n    margin=dict(l=40, r=40, t=80, b=40),\n    height=600,\n    \n    # Configure X and Y axes for JITTER-FREE animation (Fixed Ranges)\n    xaxis=dict(\n        title="Time Step (N)", showgrid=True, gridcolor=GRID_COLOR, gridwidth=1, \n        range=STABLE_X_RANGE, title_font=dict(color=FONT_COLOR), tickfont=dict(color=FONT_COLOR)\n    ),\n    yaxis=dict(\n        title="Cumulative P&L", showgrid=True, gridcolor=GRID_COLOR, gridwidth=1, \n        range=STABLE_Y_RANGE, tickformat=".2f", \n        title_font=dict(color=FONT_COLOR), tickfont=dict(color=FONT_COLOR)\n    ),\n    \n    # Zero line\n    shapes=[\n        dict(type='line', xref='x', yref='y', x0=0, y0=0, x1=1, y1=0, \n             line=dict(color=GRID_COLOR, width=1.5, dash='dash')),\n    ],\n    \n    legend=dict(x=0, y=1.05, orientation="h", bgcolor='rgba(0,0,0,0)', font=dict(color=FONT_COLOR), tracegroupgap=30),\n    \n    updatemenus=[{\n        'type': 'buttons',\n        'showactive': False,\n        'x':0.5, 'y':-0.1, 'xanchor': 'center', 'yanchor': 'top',\n        'buttons':[{\n            'label': '▶️ Play Animation',\n            'method': 'animate',\n            'args': [None, {\n                'frame': {'duration': 40, 'redraw': True},\n                'fromcurrent': True,\n                'transition': {'duration': 5, 'easing': 'linear'}, \n                'mode': 'immediate'\n            }]\n        }]\n    }]\n)\n\n# --- FINALIZE AND SHOW ---\nfig_anim.frames = frames\n\n# Footer annotation with parameters\nev_sign = '+' if EV_PER_TRADE > 0 else ''\nfig_anim.add_annotation(\n    x=0.99, y=-0.15, xref='paper', yref='paper',\n    text=f"EV per Trade: {ev_sign}{EV_PER_TRADE}. Hit Rate={hit_rate:.3f}. Volatility={VOLATILITY}",\n    showarrow=False, font=dict(color='#888888', size=10),\n    xanchor='right', yanchor='top'\n)\n\nfig_anim.show()\n# %% [markdown]\n##### How Do We Make a Market Such That We Accumulate Positive Edge?\n# %% [markdown]\n###### ______________________________________________________________________________________________________________________________________\n# %% [markdown]\n##### Finding the Mid Price\n\nIf the outcome is random, what is our best guess?\n\nWe can choose whatever price we would like for the mid price, let's denote\n\n$$\\theta = \\text{Mid Price}$$\n\nLet's look at the error function given by the mean squared error\n\n $$\n \\text{MSE}(\\theta) = \\mathbb{E} \\left[(\\theta - x)^2\\right] = \\frac{1}{6} \\sum_{x=1}^6 (\\theta - x)^2\n $$\n \nThe optimal $\\theta$ is the value that minimizes this MSE; that is,\n$$\n\\theta^* = \\underset{\\theta}{\\arg\\min} \\, \\text{MSE}(\\theta)\n$$\n\n\n# %% [python]\nimport numpy as np\nimport plotly.graph_objs as go\n\n# Define parameter space for mid price (theta)\ntheta = np.linspace(-3, 9, 400)\n\n# Dice outcomes: 1 through 6\ndice_outcomes = np.arange(1, 7)\n\n# Calculate theoretical MSE for each theta\nmse = np.array([(1/6) * np.sum((t - dice_outcomes) ** 2) for t in theta])\n\n# Find theta that minimizes MSE (should be mean of dice)\ntheta_star = dice_outcomes.mean()\nmin_mse = (1/6) * np.sum((theta_star - dice_outcomes) ** 2)\n\nfig = go.Figure()\n\n# Plot MSE curve\nfig.add_trace(\n    go.Scatter(\n        x=theta,\n        y=mse,\n        mode='lines',\n        line=dict(color='deepskyblue', width=3),\n        name='MSE vs Mid Price'\n    )\n)\n\n# Mark optimal theta\nfig.add_trace(\n    go.Scatter(\n        x=[theta_star],\n        y=[min_mse],\n        mode='markers',\n        marker=dict(size=20, color='orange', symbol='star'),\n        name='Optimal Mid Price'\n    )\n)\n\n# Vertical line at optimal theta\nfig.add_trace(\n    go.Scatter(\n        x=[theta_star, theta_star],\n        y=[mse.min() - 0.5, mse.max()],\n        mode='lines',\n        line=dict(color='orange', dash='dash', width=2),\n        showlegend=False\n    )\n)\n\nfig.update_layout(\n    title=f"MSE of Mid Price vs Dice Roll Outcome (Min at θ = {theta_star:.1f})",\n    xaxis=dict(\n        title="Mid Price (θ)",\n        showgrid=True, gridcolor="#323232", gridwidth=1,\n    ),\n    yaxis=dict(\n        title="Mean Squared Error",\n        showgrid=True, gridcolor="#323232", gridwidth=1,\n    ),\n    width=750,\n    height=410,\n    plot_bgcolor='rgba(0,0,0,0)',\n    paper_bgcolor='rgba(0,0,0,0)',\n    font=dict(color='white'),\n    legend=dict(\n        orientation='h',\n        yanchor='top',\n        y=-0.18,\n        xanchor='center',\n        x=0.5,\n        font=dict(color='white')\n    )\n)\n\nfig.show()\n\n# %% [markdown]\n##### Remark:  The value that minimizes the MSE here is given by $3.5$ which is equivalent to the dice roll's expectation!\n$$\n   \\mathbb{E}[X] = \\sum_{x} x\\,p(x) =\\frac{1}{6} \\sum_{i=1}^6 x_i = \\frac{1 + 2 + 3 + 4 + 5 + 6}{6} = 3.5\n$$\n\n# %% [markdown]\n###### ______________________________________________________________________________________________________________________________________\n# %% [markdown]\n**Why is the MSE minimized at the expectation?**\n \n The Mean Squared Error (MSE) when estimating the dice outcome with price $\\theta$ is:\n \n $$\n \\mathrm{MSE}(\\theta) = \\mathbb{E}\\left[(X - \\theta)^2\\right]\n $$\n \n Expanding this:\n \n $$\n \\mathrm{MSE}(\\theta) = \\mathbb{E}[X^2 - 2X\\theta + \\theta^2] = \\mathbb{E}[X^2] - 2\\theta \\mathbb{E}[X] + \\theta^2\n $$\n \n Since $\\mathbb{E}[X]$ and $\\mathbb{E}[X^2]$ are constants with respect to $\\theta$, this is a quadratic in $\\theta$:\n \n $$\n \\mathrm{MSE}(\\theta) = \\theta^2 - 2\\mathbb{E}[X]\\theta + \\mathbb{E}[X^2]\n $$\n \n To minimize, take the derivative with respect to $\\theta$ and set it to zero:\n \n $$\n \\frac{d}{d\\theta} \\mathrm{MSE}(\\theta) = 2\\theta - 2\\mathbb{E}[X] = 0\n $$\n \n So,\n \n $$\n \\theta^\\star = \\mathbb{E}[X]\n $$\n \n Therefore, the MSE is minimized when $\\theta$ equals the expected value of $X$—the mean of the dice roll. \n \n This is why the optimal mid price is the average outcome!\n\n ##### We can visualize this numerically and watch convergence to this solution from calculus!\n# %% [python]\nimport plotly.graph_objs as go\nimport numpy as np\n\n# Function for MSE and its gradient\ndef mse_fn(theta):\n    return (1/6) * np.sum((theta - np.arange(1,7))**2)\ndef grad_mse(theta):\n    return (1/3) * np.sum(theta - np.arange(1,7))\n\n# Gradient descent setup\ntheta_vals = []\ntangent_lines = []\nmse_vals = []\n\ntheta_init = -2.0\ntheta = theta_init\nalpha = 0.15  # Take much smaller steps!\nn_steps = 18  # Do more steps to show smaller advancements\n\nfor i in range(n_steps):\n    theta_vals.append(theta)\n    mse_vals.append(mse_fn(theta))\n    grad = grad_mse(theta)\n    # Tangent line at this theta -- extend very far (well beyond plot axes)\n    tangent_x = np.linspace(-20, 20, 2)\n    tangent_y = mse_fn(theta) + grad*(tangent_x-theta)\n    tangent_lines.append((tangent_x, tangent_y))\n    theta -= alpha * grad\n\ntheta_star = np.mean(np.arange(1,7))\n\n# Set up frames for Plotly animation\nframes = []\ntheta_range = np.linspace(-3, 9, 400)\nall_mses = (1/6) * np.sum((theta_range[:,None] - np.arange(1,7))**2, axis=1)\n\n# Compute tight ylim based on minimum and maximum of the *actual* plotted curve\nmse_margin = 0.2\nymin = all_mses.min() - mse_margin - 5\nymax = all_mses.max() + mse_margin\n\nfor i in range(n_steps):\n    t = theta_vals[i]\n    grad = grad_mse(t)\n    tangent_x, tangent_y = tangent_lines[i]\n    frame_data = [\n        go.Scatter(x=theta_range, y=all_mses, mode='lines', line=dict(color='deepskyblue', width=3), name='MSE vs Mid Price'),\n        go.Scatter(x=[theta_star], y=[mse_fn(theta_star)], mode='markers',\n                   marker=dict(size=20, color='orange', symbol='star'), name='Optimal Mid Price'),\n        go.Scatter(x=[theta_star, theta_star],\n                   y=[ymin, ymax],\n                   mode='lines', line=dict(color='orange', dash='dash', width=2), showlegend=False),\n        go.Scatter(x=[t], y=[mse_fn(t)], mode='markers', marker=dict(size=7, color='magenta'), name='Current Guess'),\n        go.Scatter(x=tangent_x, y=tangent_y, mode='lines', line=dict(color='magenta', width=2, dash='dot'),\n                   name='Tangent (Gradient)')\n    ]\n    frames.append(go.Frame(data=frame_data, name=f'step{i}', traces=[0,1,2,3,4]))\n\n# Initial figure setup\nfig = go.Figure(\n    data=frames[0].data,\n    frames=frames,\n)\nfig.update_layout(\n    title="Gradient Descent Finds θ Minimizing MSE (Expectation of Dice Roll)",\n    xaxis=dict(\n        title="Mid Price (θ)",\n        showgrid=True, gridcolor="#323232", gridwidth=1,\n        range=[-3, 9],\n    ),\n    yaxis=dict(\n        title="Mean Squared Error",\n        showgrid=True, gridcolor="#323232", gridwidth=1,\n        range=[ymin, ymax],\n    ),\n    width=750,\n    height=410,\n    plot_bgcolor='rgba(0,0,0,0)',\n    paper_bgcolor='rgba(0,0,0,0)',\n    font=dict(color='white'),\n    legend=dict(\n        orientation='h',\n        yanchor='top',\n        y=-0.38,    # Move legend lower; decreased from -0.15 for more separation\n        xanchor='center',\n        x=0.5,\n        font=dict(color='white')\n    ),\n    updatemenus=[\n        {\n            "type": "buttons",\n            "showactive": False,\n            "x": 1.08, "y": 1.2,\n            "buttons": [\n                {\n                    "label": "▶ Play",\n                    "method": "animate",\n                    "args": [None, {"frame": {"duration": 800,"redraw": True}, "fromcurrent": True}]\n                },\n                {\n                    "label": "⏸ Pause",\n                    "method": "animate",\n                    "args": [[None], {"frame": {"duration": 0, "redraw": False}, "mode": "immediate"}]\n                },\n            ],\n        }\n    ]\n)\n# Remove or hide the step slider by not passing 'sliders' to update_layout\n# (simply comment out or delete the slider code below)\n# sliders = [\n#     {\n#         "steps": [\n#             {\n#                 "method": "animate",\n#                 "label": f"{i+1}",\n#                 "args": [[f"step{i}"], {"mode": "immediate", "frame": {"duration": 0, "redraw": True}}],\n#             }\n#             for i in range(n_steps)\n#         ],\n#         "active": 0,\n#         "x": 0.12,\n#         "xanchor": "left",\n#         "y": -0.26,\n#         "yanchor": "top"\n#     }\n# ]\n# fig.update_layout(sliders=sliders)\n\nfig.show()\n\n# %% [markdown]\n##### Stability in our Mid Price\n\nIn the context of this example, our mid price does not change\n\nThe distribution is static along with all of the associated probabilities and statistics\n# %% [python]\nimport plotly.graph_objs as go\nimport plotly.subplots as sp\nimport numpy as np\n\n# Dice setup\ndice_faces = np.arange(1, 7)\npmf = np.ones_like(dice_faces) / 6\ntrue_mean = dice_faces.mean()  # 3.5\n\n# Simulate dice rolls\nn_rolls = 30\nrng = np.random.default_rng(seed=1)\nrolls = rng.choice(dice_faces, size=n_rolls)\n\n# Compute running mean for LLN visualization\nrunning_means = np.cumsum(rolls) / np.arange(1, n_rolls + 1)\n\n# For yaxis2 range padding (right/empirical mean plot)\nmin_runmean = running_means.min()\nmax_runmean = running_means.max()\n# Add extra padding for visibility around the displayed text\ny2_padding = 1.0\ny2_range = [\n    min(min_runmean, true_mean) - y2_padding,\n    max(max_runmean, true_mean) + y2_padding\n]\n\nframes = []\nfor i in range(n_rolls):\n    # PMF left panel (bars: always the same, highlight latest outcome)\n    colors = ["deepskyblue"] * 6\n    colors[rolls[i] - 1] = "orange"\n    pmf_trace = go.Bar(\n        x=dice_faces,\n        y=pmf,\n        marker=dict(color=colors),\n        width=0.7,\n        name="PMF",\n        xaxis="x1", yaxis="y1"\n    )\n    highlight_dot = go.Scatter(\n        x=[rolls[i]],\n        y=[pmf[rolls[i] - 1] + 0.02],\n        mode="markers+text",\n        marker=dict(size=18, color='orange', symbol='star'),\n        text=[f"{rolls[i]}"],\n        textposition="top center",\n        showlegend=False,\n        xaxis="x1", yaxis="y1"\n    )\n\n    # Running mean up to this step\n    mean_trace = go.Scatter(\n        x=np.arange(1, i + 2),\n        y=running_means[:i + 1],\n        mode="lines+markers",\n        line=dict(color="magenta", width=3),\n        marker=dict(size=10, color="magenta"),\n        name="Empirical Mean",\n        xaxis="x2", yaxis="y2"\n    )\n    # Current point marker as a smaller magenta circle (not star) for empirical mean plot\n    mean_now = go.Scatter(\n        x=[i + 1],\n        y=[running_means[i]],\n        mode="markers+text",\n        marker=dict(size=12, color="magenta", symbol="circle"),\n        text=[f"{running_means[i]:.2f}"],\n        textposition="bottom center",\n        showlegend=False,\n        xaxis="x2", yaxis="y2"\n    )\n    # Theoretical mean line\n    true_mean_line = go.Scatter(\n        x=[1, n_rolls],\n        y=[true_mean, true_mean],\n        mode="lines",\n        line=dict(color="deepskyblue", dash="dash", width=2),\n        name="Theoretical Mean",\n        xaxis="x2", yaxis="y2"\n    )\n\n    # Use the fixed y2_range for the empirical mean plot (so padding is consistent)\n    frames.append(go.Frame(\n        data=[pmf_trace, highlight_dot, mean_trace, mean_now, true_mean_line],\n        name=f"step{i}",\n        layout=go.Layout(\n            xaxis2=dict(\n                range=[0.5, n_rolls + 0.5],\n                title="Number of Rolls",\n                showgrid=True,\n                gridcolor="#323232",\n                gridwidth=1\n            ),\n            yaxis2=dict(\n                range=y2_range,\n                title="Empirical Mean of Rolls",\n                showgrid=True,\n                gridcolor="#323232",\n                gridwidth=1\n            )\n        )\n    ))\n\n# Make the figure\nfig = sp.make_subplots(rows=1, cols=2, subplot_titles=("Fixed Distribution PMF", "Empirical Mean Converges (LLN)"))\n\n# Add initial traces\ninit_traces = [\n    go.Bar(\n        x=dice_faces, y=pmf, marker=dict(color=["deepskyblue"]*6), width=0.7, name="PMF"\n    ),\n    go.Scatter(\n        x=[rolls[0]], y=[pmf[rolls[0] - 1] + 0.02], mode='markers+text',\n        marker=dict(size=18, color='orange', symbol='star'), text=[f"{rolls[0]}"],\n        textposition="top center", showlegend=False\n    ),\n    go.Scatter(\n        x=[1], y=[running_means[0]], mode="lines+markers", line=dict(color="magenta", width=3),\n        marker=dict(size=10, color="magenta"), name="Empirical Mean"\n    ),\n    # Right subplot current mean point as smaller magenta circle (not star)\n    go.Scatter(\n        x=[1], y=[running_means[0]], mode="markers+text",\n        marker=dict(size=12, color="magenta", symbol="circle"), text=[f"{running_means[0]:.2f}"],\n        textposition="bottom center", showlegend=False\n    ),\n    go.Scatter(\n        x=[1, n_rolls], y=[true_mean, true_mean],\n        mode="lines", line=dict(color="deepskyblue", dash="dash", width=2), name="Theoretical Mean"\n    )\n]\n\nfig.add_trace(init_traces[0], row=1, col=1)\nfig.add_trace(init_traces[1], row=1, col=1)\nfig.add_trace(init_traces[2], row=1, col=2)\nfig.add_trace(init_traces[3], row=1, col=2)\nfig.add_trace(init_traces[4], row=1, col=2)\n\nfig.frames = frames\n\nfig.update_layout(\n    title="Law of Large Numbers: Empirical Mean Converges, Distribution is Invariant",\n    width=1020, height=410,\n    plot_bgcolor='rgba(0,0,0,0)', paper_bgcolor='rgba(0,0,0,0)',\n    font=dict(color='white'),\n    legend=dict(\n        orientation='h',\n        yanchor='bottom', y=1.08,\n        xanchor='center', x=0.5,\n        font=dict(color="white")\n    ),\n    updatemenus=[\n        {\n            "type": "buttons",\n            "showactive": False,\n            "x": 0.5,\n            "y": -0.16,\n            "xanchor": "center",\n            "buttons": [\n                {\n                    "label": "▶ Play",\n                    "method": "animate",\n                    "args": [\n                        None,\n                        {\n                            "frame": {"duration": 300, "redraw": True},\n                            "fromcurrent": True,\n                            "transition": {"duration": 250, "easing": "linear"}\n                        }\n                    ]\n                },\n                {\n                    "label": "⏸ Pause",\n                    "method": "animate",\n                    "args": [[None], {"frame": {"duration": 0, "redraw": False}, "mode": "immediate"}]\n                },\n            ],\n        }\n    ],\n)\n\n# Left subplot (PMF): always the same\nfig.update_xaxes(\n    dict(title="Dice Face", range=[0.5, 6.5], tickvals=dice_faces, showgrid=True, gridcolor="#323232", gridwidth=1),\n    row=1, col=1\n)\nfig.update_yaxes(\n    dict(title="Probability", range=[0, 0.23], showgrid=True, gridcolor="#323232", gridwidth=1),\n    row=1, col=1\n)\n\n# Right subplot (Empirical mean)\nfig.update_xaxes(\n    dict(title="Number of Rolls", range=[0.5, n_rolls + 0.5], showgrid=True, gridcolor="#323232", gridwidth=1),\n    row=1, col=2\n)\nfig.update_yaxes(\n    dict(\n        title="Empirical Mean of Rolls",\n        range=y2_range,\n        showgrid=True, gridcolor="#323232", gridwidth=1\n    ),\n    row=1, col=2\n)\n\nfig.show()\n\n# %% [markdown]\n###### ______________________________________________________________________________________________________________________________________\n# %% [markdown]\n##### Quoting a Spread\n\n Let $B$ be the bid price, $A$ the ask price, and $V$ the true (unknown) value.\n\n Assume that with equal probability, you will either:\n - **Buy** from someone at your quoted bid $B$ (the other party sells to you), **or**\n - **Sell** to someone at your quoted ask $A$ (the other party buys from you).\n\n By the law of total expectation (averaging over both possible trades and the true value):\n\n $$\n \\mathbb{E}[\\text{Profit per trade}] = \\frac{1}{2} \\mathbb{E}[A - V] + \\frac{1}{2} \\mathbb{E}[V - B]\n $$\n\n where:\n - When **selling** at $A$, profit is $A - V$;\n - When **buying** at $B$, profit is $V - B$.\n\n Assuming you do not know $V$ exactly (your best estimate is $\\mathbb{E}[V]$):\n\n $$\n \\mathbb{E}[\\text{Profit per trade}] = \\frac{1}{2} (A - \\mathbb{E}[V]) + \\frac{1}{2} (\\mathbb{E}[V] - B) = \\frac{A - B}{2}\n $$\n\n So, your **expected profit per trade is half the quoted spread**:\n $$\n \\boxed{\n \\mathbb{E}[\\text{Profit per trade}] = \\frac{A - B}{2} = \\frac{\\text{Spread}}{2}\n }\n $$\n\n# %% [markdown]\n##### Let's make a market with an extremely wide spread so we can have the highest EV per trade! \n# %% [python]\nimport numpy as np\nimport plotly.graph_objs as go\n\n# -- Dice Market Animation: Simulate market-making with a wide quoted spread --\nnp.random.seed(2025)\n\ntrue_value = 3.5\nbid = 2\nask = 7\nspread = ask - bid\n\nn_steps = 120    # Total time steps\nliquidity_k = 0.85 \nhit_rate = np.exp(-liquidity_k * spread)\n\npl_history = []\ntrade_inds = []\ntrade_profits = []\ntrade_types = []  \n\ncum_pl = 0\ntime_steps = np.arange(1, n_steps + 1)\ncum_pl_series = np.zeros_like(time_steps, dtype=float)\n\nfor t in range(n_steps):\n    profit = 0\n    if np.random.uniform() < hit_rate:\n        if np.random.rand() < 0.5:\n            # You sell at ask\n            roll = np.random.randint(1, 7)\n            profit = ask - roll\n            trade_types.append('ask')\n        else:\n            # You buy at bid\n            roll = np.random.randint(1, 7)\n            profit = roll - bid\n            trade_types.append('bid')\n        \n        cum_pl += profit\n        trade_inds.append(t)\n        trade_profits.append(profit)\n    \n    cum_pl_series[t] = cum_pl\n\n\n# --- STYLING & COLOR CHOICES ---\nLINE_COLOR = '#6AAED6'      \nPROFIT_COLOR = '#198754'    \nLOSS_COLOR = '#DC3545'      \nTRADE_MARKER_COLOR = '#FFC300' \nHIGHLIGHT_SIZE = 10\nLINE_WIDTH = 3.5\nGRID_COLOR = '#505050'\nFONT_COLOR = 'white' \nSTAR_SIZE = 18\n\n# --- ZERO-JITTER AXIS SETUP ---\n\n# 1. Calculate the final, stable Y-range based on the entire data set.\nGLOBAL_Y_MAX = max(np.max(cum_pl_series), 0)\nGLOBAL_Y_MIN = min(np.min(cum_pl_series), 0)\nGLOBAL_Y_DELTA = GLOBAL_Y_MAX - GLOBAL_Y_MIN\nGLOBAL_Y_PAD = max(GLOBAL_Y_DELTA * 0.1, 1.5)\nSTABLE_Y_RANGE = [GLOBAL_Y_MIN - GLOBAL_Y_PAD, GLOBAL_Y_MAX + GLOBAL_Y_PAD]\n\n# 2. Calculate the final, stable X-range.\nX_MARGIN = 5\nSTABLE_X_RANGE = [0, n_steps + X_MARGIN]\n\n# --- CREATE ANIMATION FRAMES ---\nframes = []\n\n# Strategic stepping\nframe_steps = (\n    list(range(1, min(20, n_steps) + 1)) +\n    list(range(21, min(60, n_steps) + 1, 3)) +\n    list(range(61, n_steps + 1, 5))\n)\n\nfor i in frame_steps:\n    x = time_steps[:i]\n    y = cum_pl_series[:i]\n    current_pl = y[-1]\n    current_point_color = PROFIT_COLOR if current_pl >= 0 else LOSS_COLOR\n    \n    trades_up_to_i = [t_ind for t_ind in trade_inds if t_ind < i]\n    trade_x = [time_steps[t_ind] for t_ind in trades_up_to_i]\n    trade_y = [cum_pl_series[t_ind] for t_ind in trades_up_to_i]\n    \n    # NOTE: The frame.layout section is REMOVED to prevent range updates,\n    # thereby eliminating jitter. The axes are fixed by the main layout below.\n    frame = go.Frame(\n        data=[\n            # 1. Main Path Trace\n            go.Scatter(x=x, y=y, mode="lines", line=dict(color=LINE_COLOR, width=LINE_WIDTH), name="Cumulative P&L"),\n            # 2. Trade Event Markers\n            go.Scatter(x=trade_x, y=trade_y, mode='markers', marker=dict(size=HIGHLIGHT_SIZE, color=TRADE_MARKER_COLOR, symbol='circle-open', line=dict(width=1.5, color=TRADE_MARKER_COLOR)), name='Trades'),\n            # 3. Current Point Highlight\n            go.Scatter(x=[x[-1]], y=[y[-1]], mode='markers', marker=dict(size=STAR_SIZE, color=current_point_color, symbol='star', line=dict(width=2, color=FONT_COLOR)), name='Current Step')\n        ],\n        name=str(i),\n        # Layout only contains the annotation for the frame (no axis ranges)\n        layout=go.Layout(\n            annotations=[\n                dict(\n                    x=x[-1], y=y[-1], xref="x", yref="y",\n                    text=f"Time {i}, P&L {current_pl:.2f}",\n                    showarrow=True, arrowhead=1, ax=0, ay=-40,\n                    font=dict(color=current_point_color, size=14),\n                    bgcolor="rgba(0,0,0,0.5)", bordercolor=current_point_color\n                )\n            ]\n        )\n    )\n    frames.append(frame)\n\n# --- BASE FIGURE FOR ANIMATION ---\ninitial_i = frame_steps[0]\ninitial_x = time_steps[:initial_i]\ninitial_y = cum_pl_series[:initial_i]\ninitial_pl = initial_y[-1]\ninitial_current_point_color = PROFIT_COLOR if initial_pl >= 0 else LOSS_COLOR\n\ntrades_init = [t_ind for t_ind in trade_inds if t_ind < initial_i]\ntrades_x_init = [time_steps[t_ind] for t_ind in trades_init]\ntrades_y_init = [cum_pl_series[t_ind] for t_ind in trades_init]\n\n\nfig_anim = go.Figure(\n    data = [\n        go.Scatter(x=initial_x, y=initial_y, mode='lines', line=dict(color=LINE_COLOR, width=LINE_WIDTH), name='Cumulative P&L'),\n        go.Scatter(x=trades_x_init, y=trades_y_init, mode='markers', marker=dict(size=HIGHLIGHT_SIZE, color=TRADE_MARKER_COLOR, symbol='circle-open', line=dict(width=1.5, color=TRADE_MARKER_COLOR)), name='Trades'),\n        go.Scatter(x=[initial_x[-1]], y=[initial_y[-1]], mode="markers", marker=dict(size=STAR_SIZE, color=initial_current_point_color, symbol='star', line=dict(width=2, color=FONT_COLOR)), name='Current Step')\n    ],\n    layout=go.Layout(\n        title=dict(\n            text="\u{1F3B2} Dice Market-Making P&L Simulation: Wide Spread (Bid=2, Ask=7)",\n            x=0.5, font=dict(color=FONT_COLOR, size=24, family="Arial, sans-serif")\n        ),\n        xaxis=dict(\n            title="Time Step (Order Opportunity)",\n            showgrid=True, gridcolor=GRID_COLOR, gridwidth=1, zeroline=False,\n            range=STABLE_X_RANGE, # Fixed range here\n            title_font=dict(color=FONT_COLOR), tickfont=dict(color=FONT_COLOR)\n        ),\n        yaxis=dict(\n            title="Cumulative Profit & Loss (P&L)",\n            showgrid=True, gridcolor=GRID_COLOR, gridwidth=1,\n            range=STABLE_Y_RANGE, # Fixed range here\n            tickformat=".2f", title_font=dict(color=FONT_COLOR), tickfont=dict(color=FONT_COLOR)\n        ),\n        # Professional zero line\n        shapes=[\n            dict(\n                type='line', xref='paper', yref='y', x0=0, y0=0, x1=1, y1=0,\n                line=dict(color=GRID_COLOR, width=1.5, dash='dash')\n            )\n        ],\n        font=dict(color=FONT_COLOR, size=12),\n        plot_bgcolor='rgba(0,0,0,0)', \n        paper_bgcolor='rgba(0,0,0,0)', \n        margin=dict(l=50, r=40, t=80, b=40),\n        legend=dict(x=0.02, y=0.98, bgcolor='rgba(0,0,0,0)', bordercolor='rgba(0,0,0,0)', font=dict(color=FONT_COLOR)),\n        \n        # Subtle footer annotation for parameters\n        annotations=[\n            dict(\n                x=0.99, y=-0.1, xref='paper', yref='paper',\n                text=f"True Value=3.5, Spread={spread}, Hit Rate={hit_rate:.3f}",\n                showarrow=False, font=dict(color='#888888', size=10),\n                xanchor='right', yanchor='top'\n            )\n        ],\n        \n        # Play button styling\n        updatemenus=[{\n            'type': 'buttons',\n            'showactive': False,\n            'x':0.5, 'y':-0.21, 'xanchor': 'center', 'yanchor': 'top',\n            'buttons':[{\n                'label': '▶️ Play Animation',\n                'method': 'animate',\n                'args': [None, {\n                    'frame': {'duration': 40, 'redraw': True},\n                    'fromcurrent': True,\n                    # Added a transition duration to smooth the path growth\n                    'transition': {'duration': 5, 'easing': 'linear'}, \n                    'mode': 'immediate'\n                }]\n            }]\n        }]\n    ),\n    frames=frames\n)\n\nfig_anim.show()\n# %% [markdown]\n##### Remark: Theoretical Edge is not the same as Edge in Reality\n# %% [python]\nimport plotly.graph_objs as go\nfrom plotly.subplots import make_subplots\nimport numpy as np\n\n# Dice roll values\ndice_faces = np.arange(1, 7)\npmf = np.ones_like(dice_faces) / 6\ntrue_value = dice_faces.mean()  # 3.5\n\n# ----- Market: any spread clears (equal-prob buyer & seller) -----\nspread_range = np.linspace(0.01, 5, 100)\n# In the idealized naive world, each trade is equally likely at bid or ask\n# This trader earns (ask-true_value) if selling and (true_value-bid) if buying; both = spread/2\nexpected_profit_per_trade = spread_range / 2\n\n# ----- More realistic: trade volume decays as spread widens -----\ndef simple_liquidity_curve(spread, k=0.8):\n    """Fraction of max volume as a function of spread, steeper with higher k."""\n    # Exponential decay: for k~0.8, at spread=3, volume is ~10% of max\n    return np.exp(-k * spread)\n\nliquidity = simple_liquidity_curve(spread_range)\nexpected_profit_realistic = (spread_range / 2) * liquidity\n\n# Set up subplot\nfig2 = make_subplots(\n    rows=1, cols=2, subplot_titles=(\n        "Naive Model: Wider Spread, Higher Profit",\n        "Realistic Model: Too Wide, Profit Shrinks"\n    ),\n    horizontal_spacing=0.11\n)\n\n# --- Naive: profit always grows with spread ---\nfig2.add_trace(\n    go.Scatter(\n        x=spread_range,\n        y=expected_profit_per_trade,\n        mode='lines',\n        line=dict(color='deepskyblue', width=4),\n        name='Expected Profit per Trade',\n    ),\n    row=1, col=1\n)\n\n# Show example points: common spreads (e.g. fair, $1, $2) - For Plot 1\nfor s in [0.5, 1, 2, 3]:\n    fig2.add_trace(\n        go.Scatter(\n            x=[s],\n            y=[s/2],\n            mode="markers+text",\n            marker=dict(size=12, color='orange'),\n            text=[f"\${s:.1f}"],\n            textposition="top center",\n            showlegend=False\n        ),\n        row=1, col=1\n    )\n\n# --- Realistic: volume suppression with spread ---\nfig2.add_trace(\n    go.Scatter(\n        x=spread_range,\n        y=expected_profit_realistic,\n        mode='lines',\n        line=dict(color='violet', width=4),\n        name='Expected Profit (Volume Adjusted)',\n    ),\n    row=1, col=2\n)\n# Envelope for max profit per trade (dashed) - REMOVED AS REQUESTED\n# fig2.add_trace(\n#     go.Scatter(\n#         x=spread_range,\n#         y=expected_profit_per_trade,\n#         mode='lines',\n#         line=dict(color='deepskyblue', width=2, dash='dash'),\n#         name='(No Volume Loss)',\n#         showlegend=False\n#     ),\n#     row=1, col=2\n# )\n\n# Show effect of decay on a few spreads - For Plot 2\nfor s in [0.5, 2, 3]:\n    y0 = (s/2) * simple_liquidity_curve(s)\n    fig2.add_trace(\n        go.Scatter(\n            x=[s],\n            y=[y0],\n            mode="markers+text",\n            marker=dict(size=12, color='orange'),\n            text=[f"\${s:.1f}"],\n            textposition="top center",\n            showlegend=False\n        ),\n        row=1, col=2\n    )\n    # Thin dashed vertical lines\n    fig2.add_trace(\n        go.Scatter(\n            x=[s, s],\n            y=[0, y0],\n            mode='lines',\n            line=dict(color="gray", width=1, dash='dot'),\n            showlegend=False\n        ),\n        row=1, col=2\n    )\n\n# Shaded area for "sweet spot" in realistic plot (max profit region)\nmax_idx = np.argmax(expected_profit_realistic)\nspread_at_max = spread_range[max_idx]\nprofit_at_max = expected_profit_realistic[max_idx]\nfig2.add_trace(\n    go.Scatter(\n        x=[spread_at_max],\n        y=[profit_at_max],\n        mode="markers+text",\n        # Marker is size 18 and orange\n        marker=dict(size=18, color='orange', symbol='star'),\n        text=["Maximum"],\n        # Text font is orange\n        textfont=dict(color="orange"),\n        textposition="bottom center",\n        showlegend=False\n    ),\n    row=1, col=2\n)\n\n# Formatting to match the style\nfig2.update_layout(\n    title="Expected Profit vs. Spread Choice in Dice Market",\n    width=780, height=370,\n    plot_bgcolor='rgba(0,0,0,0)',\n    paper_bgcolor='rgba(0,0,0,0)',\n    font=dict(color='white'),\n    margin=dict(t=56, r=14, b=48, l=56),\n    xaxis1=dict(\n        title="Spread ($)",\n        showgrid=True, gridcolor="#323232", gridwidth=1,\n        zeroline=False,\n        range=[-0.1, 5.01]\n    ),\n    yaxis1=dict(\n        title="Expected Profit per Trade ($)",\n        showgrid=True, gridcolor="#323232", gridwidth=1,\n        zeroline=False,\n        range=[0, expected_profit_per_trade.max() + 0.2]\n    ),\n    xaxis2=dict(\n        title="Spread ($)",\n        showgrid=True, gridcolor="#323232", gridwidth=1,\n        zeroline=False,\n        range=[-0.1, 5.01]\n    ),\n    yaxis2=dict(\n        title="Expected Profit per Trade ($)",\n        showgrid=True, gridcolor="#323232", gridwidth=1,\n        zeroline=False,\n        # Y-axis range is [0, 0.4]\n        range=[0, 0.35]\n    ),\n    # Legend is beneath the chart\n    legend=dict(\n        orientation='h',\n        yanchor='top',\n        y=-0.2,\n        xanchor='center',\n        x=0.5,\n        font=dict(color='white')\n    )\n)\nfig2.update_annotations(font=dict(color='white'))\n# %% [markdown]\n##### When we provide a proper spread\n# %% [python]\nimport numpy as np\nimport plotly.graph_objs as go\n\n# -- Dice Market Animation: Simulate market-making with a TIGHTER quoted spread --\nnp.random.seed(2025)\n\n# --- SIMULATION PARAMETERS ---\ntrue_value = 3.5\nbid = 3  # Tighter Bid\nask = 4  # Tighter Ask\nspread = ask - bid # Spread = 1\n\nn_steps = 120    # Total time steps\nliquidity_k = 0.85  \n# The hit rate is calculated based on the new spread=1. \n# It will be much higher than the previous spread=5 (~42% vs ~1.4%)\nhit_rate = np.exp(-liquidity_k * spread) \n\npl_history = []\ntrade_inds = []\ntrade_profits = []\ntrade_types = []  \n\ncum_pl = 0\ntime_steps = np.arange(1, n_steps + 1)\ncum_pl_series = np.zeros_like(time_steps, dtype=float)\n\nfor t in range(n_steps):\n    profit = 0\n    if np.random.uniform() < hit_rate:\n        # Trade occurred (much more frequently now)\n        if np.random.rand() < 0.5:\n            # You sell at ask\n            roll = np.random.randint(1, 7)\n            profit = ask - roll\n            trade_types.append('ask')\n        else:\n            # You buy at bid\n            roll = np.random.randint(1, 7)\n            profit = roll - bid\n            trade_types.append('bid')\n        \n        cum_pl += profit\n        trade_inds.append(t)\n        trade_profits.append(profit)\n    \n    cum_pl_series[t] = cum_pl\n\n\n# --- STYLING & COLOR CHOICES (Kept for consistency) ---\nLINE_COLOR = '#6AAED6'      \nPROFIT_COLOR = '#198754'    \nLOSS_COLOR = '#DC3545'      \nTRADE_MARKER_COLOR = '#FFC300' \nHIGHLIGHT_SIZE = 10\nLINE_WIDTH = 3.5\nGRID_COLOR = '#505050'\nFONT_COLOR = 'white' \nSTAR_SIZE = 18\n\n# --- ZERO-JITTER AXIS SETUP (Fixed Ranges) ---\n\n# 1. Calculate the final, stable Y-range based on the entire data set.\nGLOBAL_Y_MAX = max(np.max(cum_pl_series), 0)\nGLOBAL_Y_MIN = min(np.min(cum_pl_series), 0)\nGLOBAL_Y_DELTA = GLOBAL_Y_MAX - GLOBAL_Y_MIN\nGLOBAL_Y_PAD = max(GLOBAL_Y_DELTA * 0.1, 1.5)\nSTABLE_Y_RANGE = [GLOBAL_Y_MIN - GLOBAL_Y_PAD, GLOBAL_Y_MAX + GLOBAL_Y_PAD]\n\n# 2. Calculate the final, stable X-range.\nX_MARGIN = 5\nSTABLE_X_RANGE = [0, n_steps + X_MARGIN]\n\n# --- CREATE ANIMATION FRAMES ---\nframes = []\n\n# Strategic stepping (Adapted to show the faster growth)\nframe_steps = (\n    list(range(1, min(20, n_steps) + 1)) +\n    list(range(21, min(60, n_steps) + 1, 3)) +\n    list(range(61, n_steps + 1, 5))\n)\n\nfor i in frame_steps:\n    x = time_steps[:i]\n    y = cum_pl_series[:i]\n    current_pl = y[-1]\n    current_point_color = PROFIT_COLOR if current_pl >= 0 else LOSS_COLOR\n    \n    trades_up_to_i = [t_ind for t_ind in trade_inds if t_ind < i]\n    trade_x = [time_steps[t_ind] for t_ind in trades_up_to_i]\n    trade_y = [cum_pl_series[t_ind] for t_ind in trades_up_to_i]\n    \n    frame = go.Frame(\n        data=[\n            # 1. Main Path Trace\n            go.Scatter(x=x, y=y, mode="lines", line=dict(color=LINE_COLOR, width=LINE_WIDTH), name="Cumulative P&L"),\n            # 2. Trade Event Markers\n            go.Scatter(x=trade_x, y=trade_y, mode='markers', marker=dict(size=HIGHLIGHT_SIZE, color=TRADE_MARKER_COLOR, symbol='circle-open', line=dict(width=1.5, color=TRADE_MARKER_COLOR)), name='Trades'),\n            # 3. Current Point Highlight\n            go.Scatter(x=[x[-1]], y=[y[-1]], mode='markers', marker=dict(size=STAR_SIZE, color=current_point_color, symbol='star', line=dict(width=2, color=FONT_COLOR)), name='Current Step')\n        ],\n        name=str(i),\n        layout=go.Layout(\n            annotations=[\n                dict(\n                    x=x[-1], y=y[-1], xref="x", yref="y",\n                    text=f"Time {i}, P&L {current_pl:.2f}",\n                    showarrow=True, arrowhead=1, ax=0, ay=-40,\n                    font=dict(color=current_point_color, size=14),\n                    bgcolor="rgba(0,0,0,0.5)", bordercolor=current_point_color\n                )\n            ]\n        )\n    )\n    frames.append(frame)\n\n# --- BASE FIGURE FOR ANIMATION ---\ninitial_i = frame_steps[0]\ninitial_x = time_steps[:initial_i]\ninitial_y = cum_pl_series[:initial_i]\ninitial_pl = initial_y[-1]\ninitial_current_point_color = PROFIT_COLOR if initial_pl >= 0 else LOSS_COLOR\n\ntrades_init = [t_ind for t_ind in trade_inds if t_ind < initial_i]\ntrades_x_init = [time_steps[t_ind] for t_ind in trades_init]\ntrades_y_init = [cum_pl_series[t_ind] for t_ind in trades_init]\n\n\nfig_anim = go.Figure(\n    data = [\n        go.Scatter(x=initial_x, y=initial_y, mode='lines', line=dict(color=LINE_COLOR, width=LINE_WIDTH), name='Cumulative P&L'),\n        go.Scatter(x=trades_x_init, y=trades_y_init, mode='markers', marker=dict(size=HIGHLIGHT_SIZE, color=TRADE_MARKER_COLOR, symbol='circle-open', line=dict(width=1.5, color=TRADE_MARKER_COLOR)), name='Trades'),\n        go.Scatter(x=[initial_x[-1]], y=[initial_y[-1]], mode="markers", marker=dict(size=STAR_SIZE, color=initial_current_point_color, symbol='star', line=dict(width=2, color=FONT_COLOR)), name='Current Step')\n    ],\n    layout=go.Layout(\n        title=dict(\n            text="\u{1F3B2} Tighter Spread Simulation: Faster P&L Accumulation (Bid=3, Ask=4)",\n            x=0.5, font=dict(color=FONT_COLOR, size=24, family="Arial, sans-serif")\n        ),\n        xaxis=dict(\n            title="Time Step (Order Opportunity)",\n            showgrid=True, gridcolor=GRID_COLOR, gridwidth=1, zeroline=False,\n            range=STABLE_X_RANGE, # Fixed range\n            title_font=dict(color=FONT_COLOR), tickfont=dict(color=FONT_COLOR)\n        ),\n        yaxis=dict(\n            title="Cumulative Profit & Loss (P&L)",\n            showgrid=True, gridcolor=GRID_COLOR, gridwidth=1,\n            range=STABLE_Y_RANGE, # Fixed range\n            tickformat=".2f", title_font=dict(color=FONT_COLOR), tickfont=dict(color=FONT_COLOR)\n        ),\n        # Professional zero line\n        shapes=[\n            dict(\n                type='line', xref='paper', yref='y', x0=0, y0=0, x1=1, y1=0,\n                line=dict(color=GRID_COLOR, width=1.5, dash='dash')\n            )\n        ],\n        font=dict(color=FONT_COLOR, size=12),\n        plot_bgcolor='rgba(0,0,0,0)', \n        paper_bgcolor='rgba(0,0,0,0)', \n        margin=dict(l=50, r=40, t=80, b=40),\n        legend=dict(x=0.02, y=0.98, bgcolor='rgba(0,0,0,0)', bordercolor='rgba(0,0,0,0)', font=dict(color=FONT_COLOR)),\n        \n        # Subtle footer annotation for parameters\n        annotations=[\n            dict(\n                x=0.99, y=-0.1, xref='paper', yref='paper',\n                text=f"True Value=3.5, Spread={spread}, Hit Rate={hit_rate:.3f} (Significantly Higher)",\n                showarrow=False, font=dict(color='#888888', size=10),\n                xanchor='right', yanchor='top'\n            )\n        ],\n        \n        # Play button styling\n        updatemenus=[{\n            'type': 'buttons',\n            'showactive': False,\n            'x':0.5, 'y':-0.21, 'xanchor': 'center', 'yanchor': 'top',\n            'buttons':[{\n                'label': '▶️ Play Animation',\n                'method': 'animate',\n                'args': [None, {\n                    'frame': {'duration': 40, 'redraw': True},\n                    'fromcurrent': True,\n                    'transition': {'duration': 5, 'easing': 'linear'}, \n                    'mode': 'immediate'\n                }]\n            }]\n        }]\n    ),\n    frames=frames\n)\n\nfig_anim.show()\n# %% [markdown]\n###### ______________________________________________________________________________________________________________________________________\n# %% [markdown]\n##### Making a Market\n\nIn our dice market, realizations occur immediately, if we quote effectively around our mid price we will accumulate profits\n\nIn reality, a derivatives contract isn't realized until maturity so we must *hedge* to accumulate the theoretical spread (discussed below)\n# %% [python]\nimport plotly.graph_objs as go\nimport plotly.subplots as sp\nimport numpy as np\n\n# Dice setup\ndice_faces = np.arange(1, 7)\npmf = np.ones_like(dice_faces) / 6\n\n# Bid/Ask market parameters\nspread = 1.5\ntrue_value = dice_faces.mean() # 3.5\nbid = true_value - spread/2\nask = true_value + spread/2\n\n# Simulate dice rolls\nn_trades = 30\nrng = np.random.default_rng(seed=1)\noutcomes = rng.choice(dice_faces, size=n_trades)\npl_list = [0] # initial P&L\nfor i in range(n_trades):\n    # we "buy" the roll at our bid, outcome settled\n    pl_list.append(pl_list[-1] + (outcomes[i] - bid))\n\n# Remove initial zero for the animation\npl_vals = pl_list[1:]\n\nframes = []\nfor i in range(n_trades):\n    # --- Dynamic Range Calculation for Right Plot ---\n    current_pl = np.array(pl_vals[:i+1])\n    \n    # xmax: current trade number + 2.5 (increased padding for text)\n    current_max_x = i + 2.5 \n    \n    # ymin: minimum P/L achieved so far, with padding (increased from 2 to 3)\n    current_min_y = min(current_pl.min() - 3, 0)\n    \n    # ymax: maximum P/L achieved so far, with padding (increased from 2 to 3)\n    current_max_y = max(current_pl.max() + 3, 0)\n\n    # Ensure min < max for y-axis\n    if current_min_y == current_max_y:\n         current_min_y -= 1\n         current_max_y += 1\n         \n    # PMF trace: highlight realized outcome\n    colors = ["deepskyblue"] * 6\n    colors[outcomes[i]-1] = "orange"\n    pmf_trace = go.Bar(\n        x=dice_faces,\n        y=pmf,\n        marker=dict(color=colors),\n        width=0.7,\n        name="PMF",\n        xaxis="x1", yaxis="y1" # Assign to 1st subplot axes\n    )\n    # Draw marker for realized outcome\n    outcome_scatter = go.Scatter(\n        x=[outcomes[i]],\n        y=[pmf[outcomes[i]-1]+0.02], # Small bump above bar\n        mode='markers+text',\n        marker=dict(size=18, color='orange', symbol='star'),\n        text=[f"{outcomes[i]}"],\n        textposition="top center",\n        showlegend=False,\n        xaxis="x1", yaxis="y1" # Assign to 1st subplot axes\n    )\n    # P&L trace up to this trade\n    pl_trace = go.Scatter(\n        x=np.arange(1,i+2),\n        y=pl_vals[:i+1],\n        mode="lines+markers",\n        line=dict(color="magenta", width=3),\n        marker=dict(size=10, color="magenta"),\n        name="Cum. P/L",\n        xaxis="x2", yaxis="y2" # Assign to 2nd subplot axes\n    )\n    # Step marker at current trade (now: magenta circle, size 10, to match the line)\n    pl_now = go.Scatter(\n        x=[i+1],\n        y=[pl_vals[i]],\n        mode="markers+text",\n        marker=dict(size=10, color="magenta", symbol="circle"),\n        text=[f"{pl_vals[i]:+.0f}"],\n        textposition="bottom center", # Text position is bottom center\n        showlegend=False,\n        xaxis="x2", yaxis="y2" # Assign to 2nd subplot axes\n    )\n    # Reference line for "fair" expected outcome (must be calculated up to current trade for frame)\n    fair_line = go.Scatter(\n        x=np.arange(1, i+2),\n        y=(true_value-bid)*np.arange(1, i+2),\n        mode="lines",\n        line=dict(color="deepskyblue", dash="dash", width=2),\n        name="E[P/L]",\n        xaxis="x2", yaxis="y2" # Assign to 2nd subplot axes\n    )\n    \n    frames.append(go.Frame(\n        data=[pmf_trace, outcome_scatter, pl_trace, pl_now, fair_line],\n        name=f"step{i}",\n        # --- Update layout for right plot in the frame ---\n        layout=go.Layout(\n            xaxis2=dict(\n                range=[0.5, current_max_x], \n                title="Trade #", \n                showgrid=True, \n                gridcolor="#323232", \n                gridwidth=1\n            ),\n            yaxis2=dict(\n                range=[current_min_y, current_max_y], \n                title="Our Cumulative P/L",\n                showgrid=True, \n                gridcolor="#323232", \n                gridwidth=1\n            )\n        )\n        # -------------------------------------------------\n    ))\n\n# Create figure with 1 row and 2 columns\nfig = sp.make_subplots(rows=1, cols=2)\n\n# Initial traces for frame 0 (must be explicitly added to the fig)\ninit_traces = [\n    go.Bar(\n        x=dice_faces, y=pmf, marker=dict(color=["deepskyblue"]*6), width=0.7, name="PMF"\n    ),\n    go.Scatter(\n        x=[outcomes[0]], y=[pmf[outcomes[0]-1]+0.02], mode='markers+text',\n        marker=dict(size=18, color='orange', symbol='star'), text=[f"{outcomes[0]}"],\n        textposition="top center", showlegend=False\n    ),\n    go.Scatter(\n        x=[1], y=[pl_vals[0]], mode="lines+markers", line=dict(color="magenta", width=3),\n        marker=dict(size=10, color="magenta"), name="Cum. P/L"\n    ),\n    # Step marker: magenta circle, size 10 to match line\n    go.Scatter(\n        x=[1], y=[pl_vals[0]], mode="markers+text",\n        marker=dict(size=10, color="magenta", symbol="circle"), text=[f"{pl_vals[0]:+.0f}"],\n        textposition="bottom center", showlegend=False\n    ),\n    go.Scatter(\n        x=[1], y=(true_value-bid)*np.array([1]),\n        mode="lines", line=dict(color="deepskyblue", dash="dash", width=2), name="E[P/L]"\n    )\n]\n\n# Add initial traces, specifying row/col for correct placement\nfig.add_trace(init_traces[0], row=1, col=1)\nfig.add_trace(init_traces[1], row=1, col=1)\nfig.add_trace(init_traces[2], row=1, col=2)\nfig.add_trace(init_traces[3], row=1, col=2)\nfig.add_trace(init_traces[4], row=1, col=2)\n\n# Set frames on the new figure\nfig.frames = frames\n\n# Update layout\nFRAME_DURATION = 300\nAXIS_TRANSITION_DURATION = FRAME_DURATION * 0.9 \n\nfig.update_layout(\n    title="Dice Market: How Edge Accumulates",\n    width=1020, height=410,\n    plot_bgcolor='rgba(0,0,0,0)', paper_bgcolor='rgba(0,0,0,0)',\n    font=dict(color='white'),\n    legend=dict(\n        orientation='h',\n        yanchor='bottom', y=1.08,\n        xanchor='center', x=0.5,\n        font=dict(color="white")\n    ),\n    updatemenus=[\n        {\n            "type": "buttons",\n            "showactive": False,\n            "x": 0.5, \n            "y": -0.18, \n            "xanchor": "center", \n            "buttons": [\n                {\n                    "label": "▶ Play",\n                    "method": "animate",\n                    "args": [\n                        None, \n                        {\n                            "frame": {"duration": FRAME_DURATION, "redraw": True}, \n                            "fromcurrent": True,\n                            "transition": {\n                                "duration": AXIS_TRANSITION_DURATION, \n                                "easing": "linear"\n                            }\n                        }\n                    ]\n                },\n                {\n                    "label": "⏸ Pause",\n                    "method": "animate",\n                    "args": [[None], {"frame": {"duration": 0, "redraw": False}, "mode": "immediate"}]\n                },\n            ],\n        }\n    ],\n)\n# Left subplot: PMF\nfig.update_xaxes(\n    dict(title="Dice Face", range=[0.5,6.5], tickvals=dice_faces, showgrid=True, gridcolor="#323232", gridwidth=1), \n    row=1, col=1\n)\nfig.update_yaxes(\n    dict(title="Probability", range=[0,0.23], showgrid=True, gridcolor="#323232", gridwidth=1), \n    row=1, col=1\n)\n\n# Right subplot (P/L) axes\ninitial_x_range = frames[0].layout.xaxis2.range\ninitial_y_range = frames[0].layout.yaxis2.range\n\nfig.update_xaxes(\n    dict(title="Trade #", range=initial_x_range, showgrid=True, gridcolor="#323232", gridwidth=1),\n    row=1, col=2\n)\nfig.update_yaxes(\n    dict(title="Our Cumulative P/L", range=initial_y_range, showgrid=True, gridcolor="#323232", gridwidth=1),\n    row=1, col=2\n)\n\nfig.show()\n# %% [markdown]\n---\n# %% [markdown]\n#### 2.) \u{1F4C8} Making an Options Market\n\nThis idea of accumulating positive expected value works the same way in making a market for options\n\n**The Problem:** We are transacting at $t = 0$ (spot), unlike the dice market which realizes after the roll we must wait until time $T$ to realize a payoff\n# %% [python]\nimport plotly.graph_objs as go\nfrom plotly.subplots import make_subplots\n\n# Parameters for option and GBM\nK = 100          # Strike price\nS0 = 100         # Initial price\nT = 1.0          # Time to maturity (years)\nr = 0.0          # Risk-free rate\nsigma = 0.25     # Volatility\nnum_paths = 30   # Number of simulated GBM paths\nnum_steps = 100  # Steps per path\n\nnp.random.seed(42)\n\n# 1. Hockey stick diagram: Call option payoff at expiry\nS_grid = np.linspace(60, 140, 500)\ncall_payoff = np.maximum(S_grid - K, 0)\n\n# 2. GBM simulation\ndt = T / num_steps\ntimes = np.linspace(0, T, num_steps + 1)\n\ngbm_paths = []\nfor _ in range(num_paths):\n    # Brownian increments\n    rnd = np.random.normal(size=num_steps)\n    W = np.concatenate(([0], np.cumsum(np.sqrt(dt) * rnd)))\n    S_path = S0 * np.exp((r - 0.5 * sigma ** 2) * times + sigma * W)\n    gbm_paths.append(S_path)\n\n# 3. Plotting\nfig = make_subplots(\n    rows=1, cols=2, \n    subplot_titles=["Call Option Payoff at T", "Possible Underlying Paths to Expiry"],\n    horizontal_spacing=0.15\n)\n\n# Left plot: Hockey stick diagram (NO area fill)\nfig.add_trace(\n    go.Scatter(\n        x=S_grid, y=call_payoff,\n        mode='lines',\n        line=dict(color='deepskyblue', width=4),\n        name="Payoff at T",\n        showlegend=False\n    ), row=1, col=1\n)\n# Add strike line\nfig.add_trace(\n    go.Scatter(\n        x=[K, K], y=[0, max(call_payoff)],\n        mode='lines',\n        line=dict(color='orange', width=2, dash='dash'),\n        name='Strike Price (K)',\n        showlegend=False,\n    ), row=1, col=1\n)\n# Add text annotation for strike price in left plot\nfig.add_annotation(\n    x=K,\n    y=max(call_payoff)*0.95,\n    text="Strike<br>K",\n    showarrow=False,\n    xanchor="left",\n    yanchor="top",\n    font=dict(color="orange", size=13),\n    bgcolor="rgba(50,50,50,0.7)",\n    row=1, col=1\n)\n\n# Right plot: GBM paths (S vs T)\nfor i, S_path in enumerate(gbm_paths):\n    fig.add_trace(\n        go.Scatter(\n            x=times, \n            y=S_path,\n            mode='lines',\n            line=dict(\n                color='rgba(90, 140, 200, 0.35)' if i < num_paths - 1 else 'rgba(90, 140, 200, 0.45)', \n                width=2\n            ),\n            hoverinfo='skip',\n            showlegend=False\n        ),\n        row=1, col=2\n    )\n# Add horizontal strike line to right plot\nfig.add_trace(\n    go.Scatter(\n        x=[0, T], y=[K, K],\n        mode='lines',\n        line=dict(color='orange', width=2, dash='dash'),\n        name='Strike Price (K)',\n        showlegend=False\n    ),\n    row=1, col=2\n)\n# Add annotation for strike price in right plot\nfig.add_annotation(\n    x=0,\n    y=K,\n    text="Strike<br>K",\n    showarrow=False,\n    xanchor="left",\n    yanchor="bottom",\n    font=dict(color="orange", size=13),\n    bgcolor="rgba(50,50,50,0.7)",\n    row=1, col=2\n)\n# Add vertical line for T in right plot\nfig.add_trace(\n    go.Scatter(\n        x=[T, T],\n        y=[min([min(path) for path in gbm_paths + [[K]]]) * 0.98, max([max(path) for path in gbm_paths]) * 1.03],\n        mode="lines",\n        line=dict(color="lime", width=2, dash="dot"),\n        showlegend=False,\n        hoverinfo='skip'\n    ),\n    row=1, col=2\n)\n# Add annotation for T in right plot (top)\nfig.add_annotation(\n    x=T,\n    y=max([max(path) for path in gbm_paths]) * 1.029,\n    text="T",\n    showarrow=False,\n    xanchor="left",\n    yanchor="top",\n    font=dict(color="lime", size=13),\n    row=1, col=2\n)\n\n# Update all axes and layout for aesthetics matching\nfig.update_xaxes(\n    title_text="Underlying Price at T", \n    row=1, col=1,\n    showgrid=True, gridcolor="#323232", gridwidth=1,\n    range=[60, 140]\n)\nfig.update_yaxes(\n    title_text="Call Payoff", \n    row=1, col=1, \n    showgrid=True, gridcolor="#323232", gridwidth=1,\n    range=[0, max(call_payoff)*1.1]\n)\n\nfig.update_xaxes(\n    title_text="Time to Expiry (T)", \n    row=1, col=2,\n    showgrid=True, gridcolor="#323232", gridwidth=1,\n    range=[0, T]\n)\nfig.update_yaxes(\n    title_text="Underlying Price S(t)",\n    row=1, col=2,\n    showgrid=True, gridcolor="#323232", gridwidth=1,\n    range=[min([min(path) for path in gbm_paths + [[K]]]) * 0.98, max([max(path) for path in gbm_paths]) * 1.03]\n)\n\nfig.update_layout(\n    width=920, height=400,\n    plot_bgcolor='rgba(0,0,0,0)',\n    paper_bgcolor='rgba(0,0,0,0)',\n    title=dict(text="Call Option Payoff and Possible Underlying Price Paths",x=0.5, font=dict(color='white')),\n    font=dict(color='white'),\n    margin=dict(l=30, r=30, t=50, b=30),\n    showlegend=False\n)\n\nfig.show()\n\n# %% [markdown]\n###### ______________________________________________________________________________________________________________________________________\n# %% [markdown]\n##### Finding the Mid Price\n\nUnlike with the dice market, there are many acceptable mid prices depending on the model we select\n\n $$ \n \\text{GBM:} \\qquad dS_t = \\mu S_t dt + \\sigma S_t dW_t \n $$\n $$\n \\text{Heston SV:} \\qquad \\begin{cases}\n dS_t = \\mu S_t dt + \\sqrt{v_t} S_t dW_t^{(1)} \\\\\n dv_t = \\kappa (\\theta - v_t) dt + \\xi \\sqrt{v_t} dW_t^{(2)}\n \\end{cases}\n $$\n $$\n \\text{Rough Bergomi:} \\qquad \\begin{cases}\n dS_t = \\sqrt{v_t} S_t dW_t \\\\\n v_t = \\xi_0 \\exp\\Bigg( \\eta \\int_0^t (t-s)^{H-1/2} dW_s^{(2)} - \\frac{1}{2} \\eta^2 t^{2H} \\Bigg)\n \\end{cases}\n $$\n\n The "mid price" of a contingent claim, under the Fundamental Theorem of Asset Pricing (FTAP), is the expectation of its payoff under the risk-neutral measure:\n\n $$\n \\text{Mid Price} = \\mathbb{E}^{\\mathbb{Q}} \\left[ e^{-r(T-t)} h(S_T) \\mid \\mathcal{F}_t \\right]\n $$\n\n where:\n  - $ \\mathbb{Q} $ is the risk-neutral probability measure\n  - $ r $ is the risk-free interest rate\n  - $ T $ is the claim's maturity\n  - $ h(S_T) $ is the payoff of the claim at maturity\n  - $ \\mathcal{F}_t $ is the information up to time $ t $\n\n\nThough we may not be operating in a "complete" market with a unique risk-neutral measure like Black-Scholes\n\nWe calibrate to liquid instruments implicitly determining the risk-neutral measure by whatever the market is using\n# %% [python]\nimport numpy as np\nimport plotly.graph_objects as go\n\n# --- Volatility Surface Data ---\nS_unique = np.array([80, 90, 100, 110, 120])\nT_unique = np.array([0.0833, 0.25, 0.50, 1.00, 2.00])\nS_mesh, T_mesh = np.meshgrid(S_unique, T_unique)\n\nZ_market = np.array([\n    [0.35, 0.28, 0.22, 0.20, 0.18],\n    [0.33, 0.27, 0.21, 0.19, 0.17],\n    [0.32, 0.26, 0.205, 0.185, 0.165],\n    [0.31, 0.25, 0.20, 0.18, 0.16],\n    [0.30, 0.245, 0.195, 0.175, 0.155]\n])\n\n# Model initial guess is flat surface, e.g. ATM vol\nZ_model_init = np.full_like(Z_market, 0.22)\n\nn_steps = 60\n\nframes = []\nfor i in range(1, n_steps + 1):\n    t = i / n_steps\n    smooth_t = 1 - (1 - t) ** 2\n    # Partial fit: model comes closer to market data, but doesn't land exactly on it\n    alpha = 0.85\n    fit_level = alpha * smooth_t\n    Zfit_grid = (1 - fit_level) * Z_model_init + fit_level * Z_market\n\n    frames.append(go.Frame(\n        data=[\n            go.Surface(\n                x=S_mesh, y=T_mesh, z=Z_market,\n                colorscale='Viridis', opacity=0.85,\n                showscale=False, name='Market', scene='scene'\n            ),\n            go.Surface(\n                x=S_mesh, y=T_mesh, z=Zfit_grid,\n                colorscale='Blues', opacity=0.61,\n                showscale=False, name='Model (Fit)', scene='scene'\n            ),\n        ],\n        name=f'calib_{i}'\n    ))\n\n# --- Base Figure ---\nfig = go.Figure()\n\n# Initial market and model (uncalibrated) surface\nfig.add_trace(go.Surface(\n    x=S_mesh, y=T_mesh, z=Z_market,\n    colorscale='Viridis', opacity=0.85,\n    showscale=False, name='Market', scene='scene'\n))\n\nfig.add_trace(go.Surface(\n    x=S_mesh, y=T_mesh, z=Z_model_init,\n    colorscale='Blues', opacity=0.61,\n    showscale=False, name='Model (Fit)', scene='scene'\n))\n\nfig.frames = frames\n\n# --- Layout ---\nfig.update_layout(\n    title=dict(\n        text=("Calibrating Model Volatility Surface to Market"),\n        x=0.5, font=dict(size=18)\n    ),\n    height=560,\n    width=820,\n    paper_bgcolor='rgba(0,0,0,0)',\n    plot_bgcolor='rgba(0,0,0,0)',\n    font=dict(color='white'),\n    showlegend=False,\n    updatemenus=[{\n        'type': 'buttons',\n        'x': 0.35, 'y': -0.09,\n        'showactive': False,\n        'buttons': [{\n            'label': 'Play Calibration',\n            'method': 'animate',\n            'args': [None, {\n                'frame': {'duration': 55, 'redraw': True},\n                'fromcurrent': True,\n                'transition': {'duration': 0}\n            }]\n        }]\n    }],\n    scene=dict(\n        domain=dict(x=[0.0, 1.0], y=[0, 1]),\n        xaxis_title='Stock Price',\n        yaxis_title='Time to Expiry',\n        zaxis_title='Implied Volatility',\n        xaxis=dict(showgrid=True, gridcolor='darkgray', color='darkgray',\n                   backgroundcolor='rgb(20, 20, 25)'),\n        yaxis=dict(showgrid=True, gridcolor='darkgray', color='darkgray',\n                   backgroundcolor='rgb(20, 20, 25)'),\n        zaxis=dict(showgrid=True, gridcolor='darkgray', color='darkgray',\n                   backgroundcolor='rgb(20, 20, 25)'),\n        bgcolor='rgba(0,0,0,0)'\n    )\n)\n\nfig.show()\n\n# %% [markdown]\nOnce we have calibrated parameters we can simulate pricing by discretizing the SDE assuming no analytical solution exists\n\nThe finer our discretization and the more sample paths we have (by the Law of Large Numbers (LLN)) the more accurate our price!\n\n $$\n \\text{Mid Price} = \\mathbb{E}^{\\mathbb{Q}} \\left[ e^{-rT} \\cdot \\text{payoff}\\left( S_0 \\exp\\left( \\int_{0}^{T} \\sqrt{v_t}\\, dW_t^S - \\frac{1}{2} \\int_{0}^{T} v_t\\, dt \\right) \\right) \\right]\n $$\n where\n $$\n v_t = \\xi_0(t) \\exp\\left( \\eta \\int_0^t K_H(t, s)\\, dW_s^v - \\frac{1}{2} \\eta^2 t^{2H} \\right)\n $$\n\n##### Example: Monte Carlo Simulation Pricing Convergence\n# %% [python]\nimport numpy as np\nimport plotly.graph_objs as go\nfrom plotly.subplots import make_subplots\n\n# === Generic Framework: Stochastic Model + Theoretical Price + Monte Carlo ===\n# This structure works for *any* model: simply swap in your SDE, payoff, and theory.\n\n# --- MODEL PARAMETERS (Example: GBM inputs) ---\nK = 100         # Strike\nS0 = 100        # Initial value\nT = 1.0         # Maturity\nr = 0.0         # Risk-free rate\nsigma = 0.25    # Volatility\nnum_paths = 100 # Number of simulated paths\nnum_steps = 100 # Time discretization\n\nnp.random.seed(42)\ndt = T / num_steps\ntimes = np.linspace(0, T, num_steps + 1)\n\n# --- GENERIC STOCHASTIC MODEL SIMULATOR ---\ndef simulate_paths(model_func, S0, params, times, num_paths):\n    all_paths = []\n    for _ in range(num_paths):\n        path = model_func(S0, params, times)\n        all_paths.append(path)\n    return np.array(all_paths)\n\n# Example GBM model - to replace for other models as needed\ndef gbm_path(S0, params, times):\n    sigma, r = params['sigma'], params['r']\n    n_steps = len(times) - 1\n    W = np.concatenate(([0], np.cumsum(np.sqrt(times[1] - times[0]) * np.random.normal(size=n_steps))))\n    S = S0 * np.exp((r - 0.5 * sigma ** 2) * times + sigma * W)\n    return S\n\ngbm_params = dict(sigma=sigma, r=r)\nall_paths = simulate_paths(gbm_path, S0, gbm_params, times, num_paths)\n\n# --- THEORETICAL PRICE (Provide the appropriate closed-form for your model) ---\nfrom scipy.stats import norm\ndef bs_call(S, K, T, r, sigma):\n    if T == 0:\n        return np.maximum(S-K,0)\n    d1 = (np.log(S/K) + (r+0.5*sigma**2)*T)/(sigma*np.sqrt(T))\n    d2 = d1 - sigma*np.sqrt(T)\n    return S*norm.cdf(d1) - K*np.exp(-r*T)*norm.cdf(d2)\n\ndef theoretical_call_price(model, S0, K, T, r, sigma):\n    # Swap out logic for your model's analytic price if available\n    if model == "GBM":\n        return bs_call(S0, K, T, r, sigma)\n    else:\n        return None # or np.nan\n\ntheoretical = theoretical_call_price("GBM", S0, K, T, r, sigma)\n\n# --- GENERIC MONTE CARLO EMPIRICAL PRICE ---\ndef mc_empirical_prices(all_paths, K, r, T):\n    # Payoff: vectorized; replace for other options\n    payoffs = np.maximum(all_paths[:, -1] - K, 0)\n    discounted = payoffs * np.exp(-r * T)\n    means = [np.mean(discounted[:j+1]) for j in range(len(discounted))]\n    return means\n\n# --- CONSTANTS FOR PLOT ---\nMAX_TRACES_LEFT = num_paths + 1\nMAX_TRACES_RIGHT = 3\nMAX_X_RANGE_RIGHT = 115\n\n# --- PREPARE ANIMATION FRAMES ---\nframes = []\n\nfor N in range(1, num_paths + 1):\n    # --- Left: Stochastic Paths ---\n    traces_left = []\n    for i in range(N):\n        is_latest = (i == N - 1)\n        traces_left.append(go.Scatter(\n            x=times, y=all_paths[i],\n            line=dict(\n                color='rgba(90, 140, 200, 0.38)' if not is_latest else 'rgba(0,255,255,0.9)',\n                width=2 if not is_latest else 3\n            )\n        ))\n    for i in range(N, num_paths):\n        traces_left.append(go.Scatter(x=[], y=[], mode='lines'))\n    # Strike\n    traces_left.append(go.Scatter(\n        x=[0, T], y=[K, K],\n        mode='lines',\n        line=dict(color='orange', width=2, dash='dash'),\n    ))\n\n    # --- Right: MC Empirical and Theory ---\n    emp_means = mc_empirical_prices(all_paths[:N], K, r, T)\n    traces_right = []\n    # Empirical MC mean\n    traces_right.append(go.Scatter(\n        x=np.arange(1, N+1), y=emp_means,\n        mode='lines+markers',\n        line=dict(color='deepskyblue', width=4),\n        marker=dict(size=5, color='deepskyblue'),\n        name='Empirical MC Price'\n    ))\n    # Theoretical price (horizontal)\n    traces_right.append(go.Scatter(\n        x=[1, MAX_X_RANGE_RIGHT], y=[theoretical, theoretical],\n        mode='lines',\n        line=dict(color='lime', width=3, dash='dash'),\n        name="Theoretical Price"\n    ))\n    # Annotation\n    traces_right.append(go.Scatter(\n        x=[N], y=[emp_means[-1]],\n        mode='markers+text',\n        marker=dict(size=10, color='aqua'),\n        text=[f"N={N}<br>Price={emp_means[-1]:.2f}"],\n        textposition="top left",\n        showlegend=False, hoverinfo='skip'\n    ))\n\n    frames.append(go.Frame(\n        data=traces_left + traces_right,\n        name=str(N)\n    ))\n\n# --- INITIAL DATA FOR PLOT (N=1) ---\ninitial_paths = []\ninitial_paths.append(go.Scatter(\n    x=times, y=all_paths[0], mode='lines',\n    line=dict(color='rgba(0,255,255,0.9)', width=3),\n    hoverinfo='skip', showlegend=False, name=None\n))\nfor i in range(1, num_paths): \n    initial_paths.append(go.Scatter(\n        x=[], y=[], mode='lines',\n        line=dict(color='rgba(90, 140, 200, 0.38)', width=2),\n        hoverinfo='skip', showlegend=False, name=None\n    ))\ninitial_strike = go.Scatter(\n    x=[0,T], y=[K,K], mode='lines', line=dict(color='orange', width=2, dash='dash'),\n    showlegend=False, hoverinfo='skip'\n)\n\nemp_means_n1 = mc_empirical_prices(all_paths[:1], K, r, T)\ninitial_mean_line = go.Scatter(\n    x=[1], y=[emp_means_n1[0]], mode='lines+markers',\n    line=dict(color='deepskyblue', width=4),\n    marker=dict(size=5, color='deepskyblue'), name='Empirical MC Price'\n)\ninitial_theoretical_line = go.Scatter(\n    x=[1, MAX_X_RANGE_RIGHT], y=[theoretical, theoretical], mode='lines',\n    line=dict(color='lime', width=3, dash='dash'), name="Theoretical Price"\n)\ninitial_annotation = go.Scatter(\n    x=[1], y=[emp_means_n1[0]], mode='markers+text',\n    marker=dict(size=10, color='aqua'),\n    text=["N=1<br>Price={:.2f}".format(emp_means_n1[0])],\n    textposition="top left",\n    showlegend=False, hoverinfo='skip'\n)\n\ninitial_data = initial_paths + [initial_strike] + [initial_mean_line, initial_theoretical_line, initial_annotation]\n\n# --- FIGURE SETUP ---\nfig = make_subplots(\n    rows=1, cols=2,\n    column_widths=[0.5, 0.5],\n    subplot_titles=[\n        "Stochastic Model Simulated Paths", \n        "Empirical Price vs Theoretical Price"\n    ],\n    horizontal_spacing=0.15\n)\nfor i, trace in enumerate(initial_data[:MAX_TRACES_LEFT]):\n    fig.add_trace(trace, row=1, col=1)\nfor i, trace in enumerate(initial_data[MAX_TRACES_LEFT:]):\n    fig.add_trace(trace, row=1, col=2)\n\n# --- AXES/LAYOUT ---\nfig.update_xaxes(\n    title_text="Time to Expiry (T)", row=1, col=1,\n    showgrid=True, gridcolor="#323232", gridwidth=1, range=[0,T]\n)\nfig.update_yaxes(\n    title_text="Model Value $X(t)$", row=1, col=1,\n    showgrid=True, gridcolor="#323232", gridwidth=1,\n    range=[min([all_paths.min(), K]) * 0.98, all_paths.max() * 1.03]\n)\nfig.update_xaxes(\n    title_text="Number of Simulated Paths (N)", row=1, col=2,\n    showgrid=True, gridcolor="#323232", gridwidth=1,\n    range=[-5, MAX_X_RANGE_RIGHT] \n)\nfig.update_yaxes(\n    title_text="Option Price", row=1, col=2,\n    showgrid=True, gridcolor="#323232", gridwidth=1,\n    range=[0, 20]\n)\nfig.update_layout(\n    width=980, height=380,\n    plot_bgcolor='rgba(0,0,0,0)',\n    paper_bgcolor='rgba(0,0,0,0)',\n    title=dict(\n        text="Monte Carlo Framework: Empirical vs. Theoretical Price",\n        x=0.5, font=dict(color='white', size=19)\n    ),\n    font=dict(color='white'),\n    margin=dict(l=40, r=40, t=60, b=30),\n    showlegend=True,\n    updatemenus=[{\n        'type': 'buttons',\n        'x': 0.38, 'y': -0.34, \n        'showactive': False,\n        'buttons': [{\n            'label': 'Play MC',\n            'method': 'animate',\n            'args': [None, {\n                'frame': {'duration': 80, 'redraw': True},\n                'fromcurrent': True,\n                'transition': {'duration': 0}\n            }]\n        }]\n    }]\n)\nfig.frames = frames\n\nfig.show()\n# %% [markdown]\n###### ______________________________________________________________________________________________________________________________________\n# %% [markdown]\n##### Quoting a Spread\n\nIn practice, the quoted price is not just the theoretical price (e.g., as above) but contains adjustments for various risks and requirements:\n $$\n  \\text{Quoted Price} = \\mathbb{E}^{\\mathbb{Q}}[\\text{Payoff}\\ |\\ \\mathcal{F}_0]\n                      + \\text{Counterparty Risk Premium} \n                      + \\text{Liquidity Premium} \n                      + \\text{Profit Margin} \n                      + \\cdots\n $$\n\n Effectively, when we engage in a transaction, we are always *buying low* or *selling high*\n# %% [python]\nimport numpy as np\nimport plotly.graph_objs as go\nfrom scipy.stats import norm\n\n# --- SIMULATION AND PRICING PARAMETERS ---\n# Keeping the original parameters\nsim_sigma = 0.24\nsim_r = 0.0\nsim_S0 = 100\nsim_K = 100\nsim_T = 1.0\nsim_num_trades = 1000\n\nprice_sigma = 0.25\nprice_r = 0.0\nprice_S0 = 100\nprice_K = 100\nprice_T = 1.0\n\n# --- FINANCIAL FUNCTIONS ---\n\ndef simulate_terminal(sim_S0, sim_r, sim_sigma, sim_T, N):\n    Z = np.random.normal(size=N)\n    ST = sim_S0 * np.exp((sim_r - 0.5 * sim_sigma**2)*sim_T + sim_sigma * np.sqrt(sim_T) * Z)\n    return ST\n\ndef bs_call(S, K, T, r, sigma):\n    if T == 0:\n        return np.maximum(S - K, 0)\n    d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2)*T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    return S * norm.cdf(d1) - K * np.exp(-r*T) * norm.cdf(d2)\n\n# --- CALCULATIONS ---\n\n# Set random seed for reproducibility\nnp.random.seed(2025)\n\npaid_price = bs_call(price_S0, price_K, price_T, price_r, price_sigma)\nsim_STs = simulate_terminal(sim_S0, sim_r, sim_sigma, sim_T, sim_num_trades)\npayoff = np.maximum(sim_STs - sim_K, 0)\ndiscounted_payoff = payoff * np.exp(-sim_r * sim_T)\nPL_per_trade = discounted_payoff - paid_price\ncumulative_PL = np.cumsum(PL_per_trade)\nnum_points = len(cumulative_PL)\n\n# --- COLOR & STYLE CHOICES ---\nLINE_COLOR = '#6AAED6'  # Muted blue for the path\nPROFIT_COLOR = '#198754'  # Green for positive P&L\nLOSS_COLOR = '#DC3545'    # Red for negative P&L\nHIGHLIGHT_SIZE = 10\nLINE_WIDTH = 3.5\nGRID_COLOR = '#505050'\nFONT_COLOR = 'white' # Ensure text remains readable on any background\n\n# --- CREATE ANIMATION FRAMES FOR CUMULATIVE P&L ---\n\nframes = []\nstart_x = 1\n\n# Maintain the original strategic stepping for efficiency\nframe_steps = (\n    list(range(1, min(30,num_points)+1)) +\n    list(range(31, min(200,num_points)+1, 5)) +\n    list(range(205, num_points+1, 10))\n)\n\nfor i in frame_steps:\n    x = np.arange(start_x, i+1)\n    y = cumulative_PL[:i]\n    \n    # Dynamic axis range calculation for smooth zooming/panning\n    xmargin = max(5, int(0.05 * i))\n    x_range = [0, i + xmargin]\n    \n    # Pad y-axis intelligently\n    ymax = max(np.max(y), 0)\n    ymin = min(np.min(y), 0)\n    ydelta = ymax - ymin\n    ypad = max(ydelta * 0.1, 1.5) # Minimum padding of 1.5\n    y_range = [ymin - ypad, ymax + ypad]\n    \n    current_pl = y[-1]\n    highlight_color = PROFIT_COLOR if current_pl >= 0 else LOSS_COLOR\n    \n    # Create the trace for this frame\n    frame = go.Frame(\n        data=[\n            # 1. Main Path Trace\n            go.Scatter(\n                x=x, y=y,\n                mode="lines",\n                line=dict(color=LINE_COLOR, width=LINE_WIDTH),\n                name="Cumulative P&L"\n            ),\n            # 2. Current Point Highlight Trace\n            go.Scatter(\n                x=[x[-1]], y=[y[-1]],\n                mode="markers",\n                marker=dict(size=HIGHLIGHT_SIZE, color=highlight_color, symbol='circle',\n                            line=dict(width=2, color=FONT_COLOR)), # White border for emphasis\n                name="Current Trade"\n            )\n        ],\n        name=str(i),\n        layout=go.Layout(\n            xaxis=dict(range=x_range),\n            yaxis=dict(range=y_range),\n            # Add an annotation for the current P&L value\n            annotations=[\n                dict(\n                    x=x[-1], y=y[-1],\n                    xref="x", yref="y",\n                    text=f"Trade {i}: P&L {current_pl:.2f}",\n                    showarrow=True,\n                    arrowhead=1,\n                    ax=0, ay=-40,\n                    font=dict(color=highlight_color, size=14),\n                    bgcolor="rgba(0,0,0,0.5)", bordercolor=highlight_color\n                )\n            ]\n        )\n    )\n    frames.append(frame)\n\n# --- BASE FIGURE FOR ANIMATION ---\ninitial_i = frame_steps[0]\ninitial_x = np.arange(1, initial_i+1)\ninitial_y = cumulative_PL[:initial_i]\ninitial_pl = initial_y[-1]\ninitial_highlight_color = PROFIT_COLOR if initial_pl >= 0 else LOSS_COLOR\n\n# Calculate initial ranges based on initial data\ninitial_xmargin = max(5, int(0.05 * initial_i))\ninitial_x_range = [0, initial_i + initial_xmargin]\ninitial_ymax = max(np.max(initial_y), 0)\ninitial_ymin = min(np.min(initial_y), 0)\ninitial_ydelta = initial_ymax - initial_ymin\ninitial_ypad = max(initial_ydelta * 0.1, 1.5)\ninitial_y_range = [initial_ymin - initial_ypad, initial_ymax + initial_ypad]\n\n\nfig_anim = go.Figure(\n    data = [\n        # 1. Initial Main Path Trace\n        go.Scatter(\n            x=initial_x,\n            y=initial_y,\n            mode='lines',\n            line=dict(color=LINE_COLOR, width=LINE_WIDTH),\n            name='Cumulative P&L'\n        ),\n        # 2. Initial Current Point Highlight Trace\n        go.Scatter(\n            x=[initial_x[-1]],\n            y=[initial_y[-1]],\n            mode="markers",\n            marker=dict(size=HIGHLIGHT_SIZE, color=initial_highlight_color, symbol='circle',\n                        line=dict(width=2, color=FONT_COLOR)),\n            name="Current Trade"\n        )\n    ],\n    layout=go.Layout(\n        title=dict(\n            text="\u{1F4C8} Cumulative P&L Simulation: Market-Making Strategy",\n            x=0.5, font=dict(color=FONT_COLOR, size=24, family="Arial, sans-serif")\n        ),\n        xaxis=dict(\n            title="Trade Number (N)",\n            showgrid=True, gridcolor=GRID_COLOR, gridwidth=1,\n            zeroline=False,\n            range=initial_x_range,\n            title_font=dict(color=FONT_COLOR),\n            tickfont=dict(color=FONT_COLOR)\n        ),\n        yaxis=dict(\n            title="Cumulative Profit & Loss (P&L)", # No LaTeX here\n            showgrid=True, gridcolor=GRID_COLOR, gridwidth=1,\n            range=initial_y_range,\n            tickformat=".2f",\n            title_font=dict(color=FONT_COLOR),\n            tickfont=dict(color=FONT_COLOR)\n        ),\n        # Professional zero line\n        shapes=[\n            dict(\n                type='line',\n                xref='paper', yref='y',\n                x0=0, y0=0, x1=1, y1=0,\n                line=dict(color=GRID_COLOR, width=1.5, dash='dash')\n            )\n        ],\n        font=dict(color=FONT_COLOR, size=12),\n        plot_bgcolor='rgba(0,0,0,0)', # Transparent plot area\n        paper_bgcolor='rgba(0,0,0,0)', # Transparent overall background\n        margin=dict(l=50, r=40, t=80, b=40),\n        legend=dict(x=0.02, y=0.98, bgcolor='rgba(0,0,0,0)', bordercolor='rgba(0,0,0,0)', font=dict(color=FONT_COLOR)),\n        \n        # Subtle footer annotation for parameters\n        annotations=[\n            dict(\n                x=0.99, y=-0.1, xref='paper', yref='paper',\n                text=f"Sim sigma={sim_sigma}, Pricing sigma={price_sigma}, T={sim_T}",\n                showarrow=False, font=dict(color='#888888', size=10),\n                xanchor='right', yanchor='top'\n            )\n        ],\n        \n        # Play button styling\n        updatemenus=[{\n            'type': 'buttons',\n            'showactive': False,\n            'x':0.5, 'y':-0.21, 'xanchor': 'center', 'yanchor': 'top',\n            'buttons':[{\n                'label': '▶️ Play Animation',\n                'method': 'animate',\n                'args': [None, {\n                    'frame': {'duration': 40, 'redraw': True},\n                    'fromcurrent': True,\n                    'transition': {'duration': 0},\n                    'mode': 'immediate'\n                }]\n            }]\n        }]\n    ),\n    frames=frames\n)\n\nfig_anim.show()\n# %% [markdown]\n**Remark:** The simulation above assumes the payoff happens at the transaction of the contract.  This is not true!  In reality, we must hedge our exposure to get as close to the theoretical price as possible to accumulate the spread.\n# %% [markdown]\n###### ______________________________________________________________________________________________________________________________________\n# %% [markdown]\n##### Making a Market and Hedging\n\nUnlike with the dice market, the contract isn't realized until a maturity in the future so after we transact we must hedge to collect the theoretical value!\n\n $$\\Delta S + (V - \\Delta S) e^{r \\Delta t} = V \\ e^{r \\Delta t}$$\n\n# %% [python]\nimport numpy as np\nimport plotly.graph_objs as go\nfrom scipy.stats import norm\nfrom plotly.subplots import make_subplots\n\n# --- Configuration & Parameters ---\n\n# Simulation parameters (The "real-world" where the option evolves)\nSIM_R = 0.05           # Risk-free rate (r)\nSIM_T = 1.0            # Time to expiry in years (T)\nSIM_S0 = 100.0         # Initial Stock Price (S0)\nSIM_K = 100.0          # Strike Price (K)\nSIM_SIGMA = 0.30       # Volatility in the simulation\n\n# Model parameters used for pricing and delta (RN valuation)\nPRICE_SIGMA = 0.25     # Volatility assumed by the model\nPRICE_R = SIM_R\nPRICE_K = SIM_K\n\nSIM_STEPS = 252        # Number of hedging steps (daily)\nDT = SIM_T / SIM_STEPS # Time step\n\n# Plotting Styles\nLINE_COLOR_STOCK = '#6AAED6'   # Muted Blue\nLINE_COLOR_DERIV = '#FFA700'   # Vibrant Orange\nLINE_COLOR_HEDGED = '#198754'  # Deep Green\nFONT_COLOR = 'white'\nGRID_COLOR = '#505050'\n\n# Set random seed for reproducibility of the simulation path\nnp.random.seed(42)\n\n# --- Black-Scholes Functions ---\n\ndef bs_call(S, K, T, r, sigma):\n    """Black-Scholes Call Option Price"""\n    # Handle expiration: value is intrinsic max(S-K, 0)\n    if T <= 1e-6:\n        return np.maximum(S - K, 0)\n    d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    return S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n\ndef bs_delta(S, K, T, r, sigma):\n    """Black-Scholes Call Option Delta (Hedge Ratio)"""\n    # Handle expiration: delta is 1 (in-the-money) or 0 (out-of-the-money)\n    if T <= 1e-6:\n        return 1.0 if S > K else 0.0\n    d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n    return norm.cdf(d1)\n\n# --- Hedged Portfolio Simulation ---\n\nt_values = np.linspace(0, SIM_T, SIM_STEPS + 1)\nS_path = np.zeros(SIM_STEPS + 1)\nC_path = np.zeros(SIM_STEPS + 1)\nDelta_path = np.zeros(SIM_STEPS + 1)\n\n# Portfolio_Cash: The risk-free bond (cash) component of the replicating portfolio.\nPortfolio_Cash = np.zeros(SIM_STEPS + 1)\n\n# 1. Initial State (t=0)\nS_path[0] = SIM_S0\nT_rem_0 = SIM_T\nC_path[0] = bs_call(S_path[0], PRICE_K, T_rem_0, PRICE_R, PRICE_SIGMA)\nDelta_path[0] = bs_delta(S_path[0], PRICE_K, T_rem_0, PRICE_R, PRICE_SIGMA)\n\n# The replicating portfolio at t=0 must have a total value equal to the option price C0.\nPortfolio_Cash[0] = C_path[0] - Delta_path[0] * S_path[0]\n\n# --- Main Simulation Loop (Discrete Re-hedging) ---\nfor i in range(SIM_STEPS):\n    # 1. Stock Movement (Geometric Brownian Motion)\n    Z = np.random.normal()\n    S_path[i + 1] = S_path[i] * np.exp((SIM_R - 0.5 * SIM_SIGMA ** 2) * DT + SIM_SIGMA * np.sqrt(DT) * Z)\n\n    t_i_plus_1 = t_values[i + 1]\n    T_rem_i_plus_1 = SIM_T - t_i_plus_1\n\n    # 2. Option & Delta Calculation at time t_{i+1}\n    C_path[i + 1] = bs_call(S_path[i + 1], PRICE_K, T_rem_i_plus_1, PRICE_R, PRICE_SIGMA)\n    Delta_path[i + 1] = bs_delta(S_path[i + 1], PRICE_K, T_rem_i_plus_1, PRICE_R, PRICE_SIGMA)\n\n    # 3. Portfolio Update (Self-Financing Condition)\n    prev_cash_value_accrued = Portfolio_Cash[i] * np.exp(PRICE_R * DT)\n    delta_change = Delta_path[i + 1] - Delta_path[i]\n    rehedge_cost = delta_change * S_path[i + 1]\n    Portfolio_Cash[i + 1] = prev_cash_value_accrued - rehedge_cost\n\n# 4. Final P&L Calculation (At expiry T)\nFinal_Hedge_Value = Delta_path[SIM_STEPS - 1] * S_path[SIM_STEPS] + Portfolio_Cash[SIM_STEPS]\nFinal_Payoff_Liability = np.maximum(S_path[SIM_STEPS] - PRICE_K, 0)\nReplication_Error = Final_Hedge_Value - Final_Payoff_Liability\n\n# --- P&L Path Tracking ---\nV_path = Delta_path * S_path + Portfolio_Cash\nP_L_Error_path = V_path - C_path\nP_L_Error_path[0] = 0.0\nP_L_Error_path[-1] = Replication_Error\n\n# --- Calculate Ranges for Subplots ---\nY_PADDING_FACTOR = 0.05\nS_range = [S_path.min() * (1 - Y_PADDING_FACTOR), S_path.max() * (1 + Y_PADDING_FACTOR)]\nC_range = [0, C_path.max() * (1 + Y_PADDING_FACTOR)]\nmax_abs_pi = max(abs(P_L_Error_path.min()), abs(P_L_Error_path.max()))\nPi_range = [-max_abs_pi * 1.5, max_abs_pi * 1.5]\n\n# --- Figure Creation ---\n\nfig = make_subplots(\n    rows=3,\n    cols=1,\n    shared_xaxes=True,\n    vertical_spacing=0.08,\n    subplot_titles=(\n        "1. Stock Price Process (S_t)",\n        "2. Option Price (Risk-Neutral Valuation C_t)",\n        "3. Hedged Portfolio Replication Error (V_t - C_t)"\n    ),\n    row_heights=[0.35, 0.35, 0.30]\n)\n\n# --- Initialize traces: One line and one marker per subplot. ---\n# These traces are what the frames will update.\n\n# Subplot 1: Stock Price (Line & Marker)\nfig.add_trace(\n    go.Scatter(x=[t_values[0]], y=[S_path[0]], mode='lines', line=dict(color=LINE_COLOR_STOCK, width=3), name='Stock Price Path'),\n    row=1, col=1\n)\nfig.add_trace(\n    go.Scatter(x=[t_values[0]], y=[S_path[0]], mode='markers', marker=dict(size=10, color=LINE_COLOR_STOCK, symbol='circle'), name='Stock Price Marker'),\n    row=1, col=1\n)\n\n# Subplot 2: Option Price (Line & Marker)\nfig.add_trace(\n    go.Scatter(x=[t_values[0]], y=[C_path[0]], mode='lines', line=dict(color=LINE_COLOR_DERIV, width=3), name='Option Price Path'),\n    row=2, col=1\n)\nfig.add_trace(\n    go.Scatter(x=[t_values[0]], y=[C_path[0]], mode='markers', marker=dict(size=10, color=LINE_COLOR_DERIV, symbol='circle'), name='Option Price Marker'),\n    row=2, col=1\n)\n\n# Subplot 3: Replication Error (Line & Marker)\nfig.add_trace(\n    go.Scatter(x=[t_values[0]], y=[P_L_Error_path[0]], mode='lines', line=dict(color=LINE_COLOR_HEDGED, width=3), name='Replication Error Path'),\n    row=3, col=1\n)\nfig.add_trace(\n    go.Scatter(x=[t_values[0]], y=[P_L_Error_path[0]], mode='markers', marker=dict(size=10, color=LINE_COLOR_HEDGED, symbol='circle', line=dict(width=2, color=FONT_COLOR)), name='Replication Error Marker'),\n    row=3, col=1\n)\n\n# Add line at P&L = 0\nfig.add_hline(y=0, line_dash="dash", line_color="#DC3545", line_width=1.5, row=3, col=1)\n\n# --- Animation Frames ---\nframes = []\n# Animate in chunks of 5 days for smoother, faster visual\nframe_steps = list(range(0, SIM_STEPS + 1, 5)) + [SIM_STEPS]\nframe_steps = sorted(list(set(frame_steps)))\n\nfor frame_idx, i in enumerate(frame_steps):\n    current_t = t_values[:i + 1]\n\n    # The index 'i' in the path arrays is the data point for the current time step 't'.\n    current_S = S_path[i]\n    current_C = C_path[i]\n    current_pl_error = P_L_Error_path[i]\n\n    # Data for the current frame\n    frame_data = [\n        # Trace 0 (Subplot 1 Line: Stock Price Path)\n        go.Scatter(x=current_t, y=S_path[:i + 1]),\n        # Trace 1 (Subplot 1 Marker: Stock Price Marker)\n        go.Scatter(x=[current_t[-1]], y=[current_S]),\n        # Trace 2 (Subplot 2 Line: Option Price Path)\n        go.Scatter(x=current_t, y=C_path[:i + 1]),\n        # Trace 3 (Subplot 2 Marker: Option Price Marker)\n        go.Scatter(x=[current_t[-1]], y=[current_C]),\n        # Trace 4 (Subplot 3 Line: Hedged P&L Path)\n        go.Scatter(x=current_t, y=P_L_Error_path[:i + 1]),\n        # Trace 5 (Subplot 3 Marker: Hedged P&L Marker)\n        go.Scatter(x=[current_t[-1]], y=[current_pl_error]),\n    ]\n\n    highlight_color = LINE_COLOR_HEDGED if abs(current_pl_error) < 0.5 else '#DC3545'\n\n    # Annotation to show the replication error\n    frame_layout = go.Layout(\n        annotations=[\n            dict(\n                x=current_t[-1],\n                y=current_pl_error,\n                xref="x3",\n                yref="y3",\n                text=f"Day {i}: Error {current_pl_error:.2f}",\n                showarrow=True,\n                arrowhead=1,\n                ax=0,\n                ay=-40,\n                font=dict(color=FONT_COLOR, size=14),\n                bgcolor="rgba(0,0,0,0.5)",\n                bordercolor=highlight_color,\n                borderwidth=2\n            )\n        ]\n    )\n\n    frames.append(go.Frame(data=frame_data, layout=frame_layout, name=str(i)))\n\n# --- Final Figure Layout & Display ---\n\n# Ensure the initial trace displays the first point correctly before animation starts\nfig.data[0].x = [t_values[0]]\nfig.data[0].y = [S_path[0]]\nfig.data[2].x = [t_values[0]]\nfig.data[2].y = [C_path[0]]\nfig.data[4].x = [t_values[0]]\nfig.data[4].y = [P_L_Error_path[0]]\n\nfig.update_layout(\n    title=dict(\n        text="\u{1F3DB}️ Dynamic Delta-Hedge Simulation",\n        x=0.5,\n        font=dict(color=FONT_COLOR, size=24, family="Arial, sans-serif")\n    ),\n    template='plotly_dark',\n    plot_bgcolor='rgba(0,0,0,0)',\n    paper_bgcolor='rgba(0,0,0,0)',\n    height=850,\n    margin=dict(l=50, r=40, t=100, b=100),\n    showlegend=False,\n    transition={'duration': 0},  # Essential for smooth animation updates\n\n    # X-Axis Settings (Applied to the bottom one)\n    xaxis3=dict(\n        title="Time (Years)",\n        showgrid=True,\n        gridcolor=GRID_COLOR,\n        range=[t_values[0], t_values[-1]],\n        tickfont=dict(color=FONT_COLOR),\n        title_font=dict(color=FONT_COLOR, size=18)\n    ),\n\n    # Y-Axis 1: Stock Price (S_t)\n    yaxis=dict(\n        title_text="Stock Price (S_t)",\n        gridcolor=GRID_COLOR,\n        tickfont=dict(color=FONT_COLOR),\n        range=S_range,\n        title_font=dict(size=16)\n    ),\n    # Y-Axis 2: Option Value (C_t)\n    yaxis2=dict(\n        title_text="Option Value (C_t)",\n        gridcolor=GRID_COLOR,\n        tickfont=dict(color=FONT_COLOR),\n        range=C_range,\n        title_font=dict(size=16)\n    ),\n    # Y-Axis 3: P&L Error (Pi_t)\n    yaxis3=dict(\n        title_text="Replication Error",\n        gridcolor=GRID_COLOR,\n        tickformat=".2f",\n        tickfont=dict(color=FONT_COLOR),\n        range=Pi_range,\n        title_font=dict(size=16)\n    ),\n\n    # Play button configuration\n    updatemenus=[{\n        'type': 'buttons',\n        'showactive': False,\n        'x': 0.5,\n        'y': -0.1,\n        'xanchor': 'center',\n        'yanchor': 'top',\n        'buttons': [{\n            'label': '▶️ Start Replication',\n            'method': 'animate',\n            'args': [\n                None,  # Animates through all frames sequentially\n                {\n                    'frame': {'duration': 50, 'redraw': True},\n                    'fromcurrent': False, # Start from the beginning\n                    'transition': {'duration': 0}\n                }\n            ]\n        }]\n    }]\n)\n\n# Crucial step: Assign frames directly to the Figure object\nfig.frames = frames\n\nfig.show()\n# %% [markdown]\nTheoretically, if we have a perfect hedge, the hedged portfolio value is the theoretical price of the option in the risk-neutral sense\n\nThis is the Black-Scholes portfolio replication argument for a complete market which is precisely the no-arbitrage price (Feynman-Kac)\n\nSince we transacted at that theoretical price at the bid or ask/offer we have effectively then bought low or sold high\n\nIn reality, if we then hedge effectively we will accumulate that theoretical spread, realistic hedging however will chip away at our profits!\n# %% [markdown]\n---\n# %% [markdown]\n#### 3.) \u{1F4AD} Closing Thoughts and Future Topics\n\n**TL;DW Executive Summary**\n\n- In the face of structured randomness (dice roll market) or uncertainty (the markets) we can apply probability and statistics to systematically make money\n- When distributions are fixed, the expected value (mean, average) gives us a best guess in the MSE OOS sense, should we transact in the market around that price (quote a bid, ask/offer) we will accumulate drift even with an entirely random outcome\n- In reality, distributions change, the same principles hold but we need to calibrate models to the markets to find the appropriate parameter set to derive our mid price, in other words, to use the relevant non-unique risk-neutral measure displayed in current market prices (vol surface calibration)\n- Once a parameter set is selected we can use the law of large numbers to simulate the theoretical (mid) price of our contract and quote a spread around it\n- Unlike the dice market, where realizations occur instantly, we will have to hedge throughout the life of our position to collect the spread\n- Theoretically, continuous hedging with no transaction costs result in the simulated price of our contract so our position would be net zero if we transacted at mid but we transact at the bid or ask/offer giving us an edge to accumulate\n- Therefore, since markets are not frictionless, the efficacy of our hedge dictates how effectively we collect our spread and serve the business function of a market-maker\n\n**Future Topics**\n\nTechnical Videos and Other Discussions\n\n- Quant Roadmap\n- Projects that Made me a Quant\n- Advanced Markov Chains (Absorbing States, Communication Classes, Ergodicity and Stationary Distributions, . . .)\n- Non-Markovian Models (fractional Brownian motion, Volterra Process)\n- Deriving the Black-Scholes Equation: PDE, Analytical/Numerical Solutions\n- Kalman Filters and Non-Stationary (A Big Problem in Quant Modeling)\n- Risk-Neutral Measures (Complete vs Incomplete Markets)\n- Reinforcement Learning for Delta Hedging\n- Approximating Pricing Functionals using Neural Networks\n- Rough Path Theorey, Applications of Path Signatures\n\n[Ideas for Interactive Brokers Apps and Tutorials](https://www.interactivebrokers.com/mkt/?src=quantguildY&url=%2Fen%2Fwhyib%2Foverview.php)\n\n- Live Neural Network Stochastic Volatility Model Calibration\n- Live Kalman Filter Model with Regime Dynamics (MCs/HMMs) \n- Automated Delta-Neutral Trading System\n# %% [markdown]\n---\n# %% [markdown]\n####  $\\text{Copyright © 2025 Quant Guild} \\quad \\quad \\quad \\quad \\text{Author: Roman Paolucci}$`;
            window.starboardArtifactsUrl = `https://cdn.jsdelivr.net/npm/starboard-notebook@0.15.2/dist/`;
        </script>
        <script src="https://cdn.jsdelivr.net/npm/starboard-notebook@0.15.2/dist/starboard-notebook.js"></script>
    </body>
</html>